###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.6.53336/W32 for ARM     25/Jun/2014  14:55:03 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\S #
#                    ensor9Axis\MPU6050.cpp                                   #
#    Command line =  D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\S #
#                    ensor9Axis\MPU6050.cpp -D USE_STDPERIPH_DRIVER -lcN      #
#                    D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\p #
#                    roject\Debug\List\ -lb D:\zWk.Src\Mango-M32-MPU-9150\m32 #
#                    _Sensor_mpu9150_9Axis\project\Debug\List\                #
#                    --diag_suppress Pe549,Pa082 -o                           #
#                    D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\p #
#                    roject\Debug\Obj\ --no_cse --no_unroll --no_inline       #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0_0\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu91 #
#                    50_9Axis\project\..\inc\ -I                              #
#                    D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\p #
#                    roject\..\Sensor9Axis\ -I D:\zWk.Src\Mango-M32-MPU-9150\ #
#                    m32_Sensor_mpu9150_9Axis\project\..\PCA9555_GPIO_Ext\    #
#                    -I D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axi #
#                    s\project\..\OLED\ -I D:\zWk.Src\Mango-M32-MPU-9150\m32_ #
#                    Sensor_mpu9150_9Axis\project\..\SRAM\ -I                 #
#                    D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\p #
#                    roject\..\Libraries\STM32_USB-FS-Device_Driver\inc\ -I   #
#                    D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\p #
#                    roject\..\Libraries\STM32F10x_StdPeriph_Driver\inc\ -I   #
#                    D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\p #
#                    roject\..\Libraries\CMSIS\Device\ST\STM32F10x\Include\   #
#                    -On --eec++ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0_0\arm\CMSIS\Include\"     #
#    List file    =  D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\p #
#                    roject\Debug\List\MPU6050.lst                            #
#    Object file  =  D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\p #
#                    roject\Debug\Obj\MPU6050.o                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\zWk.Src\Mango-M32-MPU-9150\m32_Sensor_mpu9150_9Axis\Sensor9Axis\MPU6050.cpp
      1          /* ============================================
      2          I2Cdev device library code is placed under the MIT license
      3          Copyright (c) 2012 Jeff Rowberg
      4          
      5          Permission is hereby granted, free of charge, to any person obtaining a copy
      6          of this software and associated documentation files (the "Software"), to deal
      7          in the Software without restriction, including without limitation the rights
      8          to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      9          copies of the Software, and to permit persons to whom the Software is
     10          furnished to do so, subject to the following conditions:
     11          
     12          The above copyright notice and this permission notice shall be included in
     13          all copies or substantial portions of the Software.
     14          
     15          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16          IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     17          FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     18          AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     19          LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     20          OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     21          THE SOFTWARE.
     22          ===============================================
     23          */
     24          
     25          #include "MPU6050.h"
     26          #include "I2Cdev.h"
     27          
     28          /** Default constructor, uses default I2C address.
     29           * @see MPU6050_DEFAULT_ADDRESS
     30           */
     31          MPU6050::MPU6050() {
     32              devAddr = MPU6050_DEFAULT_ADDRESS;
     33          }
     34          
     35          /** Specific address constructor.
     36           * @param address I2C address
     37           * @see MPU6050_DEFAULT_ADDRESS
     38           * @see MPU6050_ADDRESS_AD0_LOW
     39           * @see MPU6050_ADDRESS_AD0_HIGH
     40           */
     41          MPU6050::MPU6050(uint8_t address) {
     42              devAddr = address;
     43          }
     44          
     45          /** Power on and prepare for general usage.
     46           * This will activate the device and take it out of sleep mode (which must be done
     47           * after start-up). This function also sets both the accelerometer and the gyroscope
     48           * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
     49           * the clock source to use the X Gyro for reference, which is slightly better than
     50           * the default internal clock source.
     51           */
     52          void MPU6050::initialize() {
     53              setClockSource(MPU6050_CLOCK_PLL_XGYRO);
     54              setFullScaleGyroRange(MPU6050_GYRO_FS_250);
     55              setFullScaleAccelRange(MPU6050_ACCEL_FS_2);
     56              setSleepEnabled(false); // thanks to Jack Elston for pointing this one out!
     57          }
     58          
     59          /** Verify the I2C connection.
     60           * Make sure the device is connected and responds as expected.
     61           * @return True if connection is valid, false otherwise
     62           */
     63          bool MPU6050::testConnection() {
     64              return getDeviceID() == 0x34;
     65          }
     66          
     67          // AUX_VDDIO register (InvenSense demo code calls this RA_*G_OFFS_TC)
     68          
     69          /** Get the auxiliary I2C supply voltage level.
     70           * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to
     71           * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to
     72           * the MPU-6000, which does not have a VLOGIC pin.
     73           * @return I2C supply voltage level (0=VLOGIC, 1=VDD)
     74           */
     75          uint8_t MPU6050::getAuxVDDIOLevel() {
     76              I2Cdev::readBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, buffer);
     77              return buffer[0];
     78          }
     79          /** Set the auxiliary I2C supply voltage level.
     80           * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to
     81           * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to
     82           * the MPU-6000, which does not have a VLOGIC pin.
     83           * @param level I2C supply voltage level (0=VLOGIC, 1=VDD)
     84           */
     85          void MPU6050::setAuxVDDIOLevel(uint8_t level) {
     86              I2Cdev::writeBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, level);
     87          }
     88          
     89          // SMPLRT_DIV register
     90          
     91          /** Get gyroscope output rate divider.
     92           * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero
     93           * Motion detection, and Free Fall detection are all based on the Sample Rate.
     94           * The Sample Rate is generated by dividing the gyroscope output rate by
     95           * SMPLRT_DIV:
     96           *
     97           * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
     98           *
     99           * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
    100           * 7), and 1kHz when the DLPF is enabled (see Register 26).
    101           *
    102           * Note: The accelerometer output rate is 1kHz. This means that for a Sample
    103           * Rate greater than 1kHz, the same accelerometer sample may be output to the
    104           * FIFO, DMP, and sensor registers more than once.
    105           *
    106           * For a diagram of the gyroscope and accelerometer signal paths, see Section 8
    107           * of the MPU-6000/MPU-6050 Product Specification document.
    108           *
    109           * @return Current sample rate
    110           * @see MPU6050_RA_SMPLRT_DIV
    111           */
    112          uint8_t MPU6050::getRate() {
    113              I2Cdev::readByte(devAddr, MPU6050_RA_SMPLRT_DIV, buffer);
    114              return buffer[0];
    115          }
    116          /** Set gyroscope sample rate divider.
    117           * @param rate New sample rate divider
    118           * @see getRate()
    119           * @see MPU6050_RA_SMPLRT_DIV
    120           */
    121          void MPU6050::setRate(uint8_t rate) {
    122              I2Cdev::writeByte(devAddr, MPU6050_RA_SMPLRT_DIV, rate);
    123          }
    124          
    125          // CONFIG register
    126          
    127          /** Get external FSYNC configuration.
    128           * Configures the external Frame Synchronization (FSYNC) pin sampling. An
    129           * external signal connected to the FSYNC pin can be sampled by configuring
    130           * EXT_SYNC_SET. Signal changes to the FSYNC pin are latched so that short
    131           * strobes may be captured. The latched FSYNC signal will be sampled at the
    132           * Sampling Rate, as defined in register 25. After sampling, the latch will
    133           * reset to the current FSYNC signal state.
    134           *
    135           * The sampled value will be reported in place of the least significant bit in
    136           * a sensor data register determined by the value of EXT_SYNC_SET according to
    137           * the following table.
    138           *
    139           * <pre>
    140           * EXT_SYNC_SET | FSYNC Bit Location
    141           * -------------+-------------------
    142           * 0            | Input disabled
    143           * 1            | TEMP_OUT_L[0]
    144           * 2            | GYRO_XOUT_L[0]
    145           * 3            | GYRO_YOUT_L[0]
    146           * 4            | GYRO_ZOUT_L[0]
    147           * 5            | ACCEL_XOUT_L[0]
    148           * 6            | ACCEL_YOUT_L[0]
    149           * 7            | ACCEL_ZOUT_L[0]
    150           * </pre>
    151           *
    152           * @return FSYNC configuration value
    153           */
    154          uint8_t MPU6050::getExternalFrameSync() {
    155              I2Cdev::readBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, buffer);
    156              return buffer[0];
    157          }
    158          /** Set external FSYNC configuration.
    159           * @see getExternalFrameSync()
    160           * @see MPU6050_RA_CONFIG
    161           * @param sync New FSYNC configuration value
    162           */
    163          void MPU6050::setExternalFrameSync(uint8_t sync) {
    164              I2Cdev::writeBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, sync);
    165          }
    166          /** Get digital low-pass filter configuration.
    167           * The DLPF_CFG parameter sets the digital low pass filter configuration. It
    168           * also determines the internal sampling rate used by the device as shown in
    169           * the table below.
    170           *
    171           * Note: The accelerometer output rate is 1kHz. This means that for a Sample
    172           * Rate greater than 1kHz, the same accelerometer sample may be output to the
    173           * FIFO, DMP, and sensor registers more than once.
    174           *
    175           * <pre>
    176           *          |   ACCELEROMETER    |           GYROSCOPE
    177           * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate
    178           * ---------+-----------+--------+-----------+--------+-------------
    179           * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz
    180           * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz
    181           * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz
    182           * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz
    183           * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz
    184           * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz
    185           * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz
    186           * 7        |   -- Reserved --   |   -- Reserved --   | Reserved
    187           * </pre>
    188           *
    189           * @return DLFP configuration
    190           * @see MPU6050_RA_CONFIG
    191           * @see MPU6050_CFG_DLPF_CFG_BIT
    192           * @see MPU6050_CFG_DLPF_CFG_LENGTH
    193           */
    194          uint8_t MPU6050::getDLPFMode() {
    195              I2Cdev::readBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, buffer);
    196              return buffer[0];
    197          }
    198          /** Set digital low-pass filter configuration.
    199           * @param mode New DLFP configuration setting
    200           * @see getDLPFBandwidth()
    201           * @see MPU6050_DLPF_BW_256
    202           * @see MPU6050_RA_CONFIG
    203           * @see MPU6050_CFG_DLPF_CFG_BIT
    204           * @see MPU6050_CFG_DLPF_CFG_LENGTH
    205           */
    206          void MPU6050::setDLPFMode(uint8_t mode) {
    207              I2Cdev::writeBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);
    208          }
    209          
    210          // GYRO_CONFIG register
    211          
    212          /** Get full-scale gyroscope range.
    213           * The FS_SEL parameter allows setting the full-scale range of the gyro sensors,
    214           * as described in the table below.
    215           *
    216           * <pre>
    217           * 0 = +/- 250 degrees/sec
    218           * 1 = +/- 500 degrees/sec
    219           * 2 = +/- 1000 degrees/sec
    220           * 3 = +/- 2000 degrees/sec
    221           * </pre>
    222           *
    223           * @return Current full-scale gyroscope range setting
    224           * @see MPU6050_GYRO_FS_250
    225           * @see MPU6050_RA_GYRO_CONFIG
    226           * @see MPU6050_GCONFIG_FS_SEL_BIT
    227           * @see MPU6050_GCONFIG_FS_SEL_LENGTH
    228           */
    229          uint8_t MPU6050::getFullScaleGyroRange() {
    230              I2Cdev::readBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, buffer);
    231              return buffer[0];
    232          }
    233          /** Set full-scale gyroscope range.
    234           * @param range New full-scale gyroscope range value
    235           * @see getFullScaleRange()
    236           * @see MPU6050_GYRO_FS_250
    237           * @see MPU6050_RA_GYRO_CONFIG
    238           * @see MPU6050_GCONFIG_FS_SEL_BIT
    239           * @see MPU6050_GCONFIG_FS_SEL_LENGTH
    240           */
    241          void MPU6050::setFullScaleGyroRange(uint8_t range) {
    242              I2Cdev::writeBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);
    243          }
    244          
    245          // ACCEL_CONFIG register
    246          
    247          /** Get self-test enabled setting for accelerometer X axis.
    248           * @return Self-test enabled value
    249           * @see MPU6050_RA_ACCEL_CONFIG
    250           */
    251          bool MPU6050::getAccelXSelfTest() {
    252              I2Cdev::readBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_XA_ST_BIT, buffer);
    253              return buffer[0];
    254          }
    255          /** Get self-test enabled setting for accelerometer X axis.
    256           * @param enabled Self-test enabled value
    257           * @see MPU6050_RA_ACCEL_CONFIG
    258           */
    259          void MPU6050::setAccelXSelfTest(bool enabled) {
    260              I2Cdev::writeBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_XA_ST_BIT, enabled);
    261          }
    262          /** Get self-test enabled value for accelerometer Y axis.
    263           * @return Self-test enabled value
    264           * @see MPU6050_RA_ACCEL_CONFIG
    265           */
    266          bool MPU6050::getAccelYSelfTest() {
    267              I2Cdev::readBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_YA_ST_BIT, buffer);
    268              return buffer[0];
    269          }
    270          /** Get self-test enabled value for accelerometer Y axis.
    271           * @param enabled Self-test enabled value
    272           * @see MPU6050_RA_ACCEL_CONFIG
    273           */
    274          void MPU6050::setAccelYSelfTest(bool enabled) {
    275              I2Cdev::writeBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_YA_ST_BIT, enabled);
    276          }
    277          /** Get self-test enabled value for accelerometer Z axis.
    278           * @return Self-test enabled value
    279           * @see MPU6050_RA_ACCEL_CONFIG
    280           */
    281          bool MPU6050::getAccelZSelfTest() {
    282              I2Cdev::readBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ZA_ST_BIT, buffer);
    283              return buffer[0];
    284          }
    285          /** Set self-test enabled value for accelerometer Z axis.
    286           * @param enabled Self-test enabled value
    287           * @see MPU6050_RA_ACCEL_CONFIG
    288           */
    289          void MPU6050::setAccelZSelfTest(bool enabled) {
    290              I2Cdev::writeBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ZA_ST_BIT, enabled);
    291          }
    292          /** Get full-scale accelerometer range.
    293           * The FS_SEL parameter allows setting the full-scale range of the accelerometer
    294           * sensors, as described in the table below.
    295           *
    296           * <pre>
    297           * 0 = +/- 2g
    298           * 1 = +/- 4g
    299           * 2 = +/- 8g
    300           * 3 = +/- 16g
    301           * </pre>
    302           *
    303           * @return Current full-scale accelerometer range setting
    304           * @see MPU6050_ACCEL_FS_2
    305           * @see MPU6050_RA_ACCEL_CONFIG
    306           * @see MPU6050_ACONFIG_AFS_SEL_BIT
    307           * @see MPU6050_ACONFIG_AFS_SEL_LENGTH
    308           */
    309          uint8_t MPU6050::getFullScaleAccelRange() {
    310              I2Cdev::readBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, buffer);
    311              return buffer[0];
    312          }
    313          /** Set full-scale accelerometer range.
    314           * @param range New full-scale accelerometer range setting
    315           * @see getFullScaleAccelRange()
    316           */
    317          void MPU6050::setFullScaleAccelRange(uint8_t range) {
    318              I2Cdev::writeBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, range);
    319          }
    320          /** Get the high-pass filter configuration.
    321           * The DHPF is a filter module in the path leading to motion detectors (Free
    322           * Fall, Motion threshold, and Zero Motion). The high pass filter output is not
    323           * available to the data registers (see Figure in Section 8 of the MPU-6000/
    324           * MPU-6050 Product Specification document).
    325           *
    326           * The high pass filter has three modes:
    327           *
    328           * <pre>
    329           *    Reset: The filter output settles to zero within one sample. This
    330           *           effectively disables the high pass filter. This mode may be toggled
    331           *           to quickly settle the filter.
    332           *
    333           *    On:    The high pass filter will pass signals above the cut off frequency.
    334           *
    335           *    Hold:  When triggered, the filter holds the present sample. The filter
    336           *           output will be the difference between the input sample and the held
    337           *           sample.
    338           * </pre>
    339           *
    340           * <pre>
    341           * ACCEL_HPF | Filter Mode | Cut-off Frequency
    342           * ----------+-------------+------------------
    343           * 0         | Reset       | None
    344           * 1         | On          | 5Hz
    345           * 2         | On          | 2.5Hz
    346           * 3         | On          | 1.25Hz
    347           * 4         | On          | 0.63Hz
    348           * 7         | Hold        | None
    349           * </pre>
    350           *
    351           * @return Current high-pass filter configuration
    352           * @see MPU6050_DHPF_RESET
    353           * @see MPU6050_RA_ACCEL_CONFIG
    354           */
    355          uint8_t MPU6050::getDHPFMode() {
    356              I2Cdev::readBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ACCEL_HPF_BIT, MPU6050_ACONFIG_ACCEL_HPF_LENGTH, buffer);
    357              return buffer[0];
    358          }
    359          /** Set the high-pass filter configuration.
    360           * @param bandwidth New high-pass filter configuration
    361           * @see setDHPFMode()
    362           * @see MPU6050_DHPF_RESET
    363           * @see MPU6050_RA_ACCEL_CONFIG
    364           */
    365          void MPU6050::setDHPFMode(uint8_t bandwidth) {
    366              I2Cdev::writeBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ACCEL_HPF_BIT, MPU6050_ACONFIG_ACCEL_HPF_LENGTH, bandwidth);
    367          }
    368          
    369          // FF_THR register
    370          
    371          /** Get free-fall event acceleration threshold.
    372           * This register configures the detection threshold for Free Fall event
    373           * detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is detected when the
    374           * absolute value of the accelerometer measurements for the three axes are each
    375           * less than the detection threshold. This condition increments the Free Fall
    376           * duration counter (Register 30). The Free Fall interrupt is triggered when the
    377           * Free Fall duration counter reaches the time specified in FF_DUR.
    378           *
    379           * For more details on the Free Fall detection interrupt, see Section 8.2 of the
    380           * MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and
    381           * 58 of this document.
    382           *
    383           * @return Current free-fall acceleration threshold value (LSB = 2mg)
    384           * @see MPU6050_RA_FF_THR
    385           */
    386          uint8_t MPU6050::getFreefallDetectionThreshold() {
    387              I2Cdev::readByte(devAddr, MPU6050_RA_FF_THR, buffer);
    388              return buffer[0];
    389          }
    390          /** Get free-fall event acceleration threshold.
    391           * @param threshold New free-fall acceleration threshold value (LSB = 2mg)
    392           * @see getFreefallDetectionThreshold()
    393           * @see MPU6050_RA_FF_THR
    394           */
    395          void MPU6050::setFreefallDetectionThreshold(uint8_t threshold) {
    396              I2Cdev::writeByte(devAddr, MPU6050_RA_FF_THR, threshold);
    397          }
    398          
    399          // FF_DUR register
    400          
    401          /** Get free-fall event duration threshold.
    402           * This register configures the duration counter threshold for Free Fall event
    403           * detection. The duration counter ticks at 1kHz, therefore FF_DUR has a unit
    404           * of 1 LSB = 1 ms.
    405           *
    406           * The Free Fall duration counter increments while the absolute value of the
    407           * accelerometer measurements are each less than the detection threshold
    408           * (Register 29). The Free Fall interrupt is triggered when the Free Fall
    409           * duration counter reaches the time specified in this register.
    410           *
    411           * For more details on the Free Fall detection interrupt, see Section 8.2 of
    412           * the MPU-6000/MPU-6050 Product Specification document as well as Registers 56
    413           * and 58 of this document.
    414           *
    415           * @return Current free-fall duration threshold value (LSB = 1ms)
    416           * @see MPU6050_RA_FF_DUR
    417           */
    418          uint8_t MPU6050::getFreefallDetectionDuration() {
    419              I2Cdev::readByte(devAddr, MPU6050_RA_FF_DUR, buffer);
    420              return buffer[0];
    421          }
    422          /** Get free-fall event duration threshold.
    423           * @param duration New free-fall duration threshold value (LSB = 1ms)
    424           * @see getFreefallDetectionDuration()
    425           * @see MPU6050_RA_FF_DUR
    426           */
    427          void MPU6050::setFreefallDetectionDuration(uint8_t duration) {
    428              I2Cdev::writeByte(devAddr, MPU6050_RA_FF_DUR, duration);
    429          }
    430          
    431          // MOT_THR register
    432          
    433          /** Get motion detection event acceleration threshold.
    434           * This register configures the detection threshold for Motion interrupt
    435           * generation. The unit of MOT_THR is 1LSB = 2mg. Motion is detected when the
    436           * absolute value of any of the accelerometer measurements exceeds this Motion
    437           * detection threshold. This condition increments the Motion detection duration
    438           * counter (Register 32). The Motion detection interrupt is triggered when the
    439           * Motion Detection counter reaches the time count specified in MOT_DUR
    440           * (Register 32).
    441           *
    442           * The Motion interrupt will indicate the axis and polarity of detected motion
    443           * in MOT_DETECT_STATUS (Register 97).
    444           *
    445           * For more details on the Motion detection interrupt, see Section 8.3 of the
    446           * MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and
    447           * 58 of this document.
    448           *
    449           * @return Current motion detection acceleration threshold value (LSB = 2mg)
    450           * @see MPU6050_RA_MOT_THR
    451           */
    452          uint8_t MPU6050::getMotionDetectionThreshold() {
    453              I2Cdev::readByte(devAddr, MPU6050_RA_MOT_THR, buffer);
    454              return buffer[0];
    455          }
    456          /** Set free-fall event acceleration threshold.
    457           * @param threshold New motion detection acceleration threshold value (LSB = 2mg)
    458           * @see getMotionDetectionThreshold()
    459           * @see MPU6050_RA_MOT_THR
    460           */
    461          void MPU6050::setMotionDetectionThreshold(uint8_t threshold) {
    462              I2Cdev::writeByte(devAddr, MPU6050_RA_MOT_THR, threshold);
    463          }
    464          
    465          // MOT_DUR register
    466          
    467          /** Get motion detection event duration threshold.
    468           * This register configures the duration counter threshold for Motion interrupt
    469           * generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit
    470           * of 1LSB = 1ms. The Motion detection duration counter increments when the
    471           * absolute value of any of the accelerometer measurements exceeds the Motion
    472           * detection threshold (Register 31). The Motion detection interrupt is
    473           * triggered when the Motion detection counter reaches the time count specified
    474           * in this register.
    475           *
    476           * For more details on the Motion detection interrupt, see Section 8.3 of the
    477           * MPU-6000/MPU-6050 Product Specification document.
    478           *
    479           * @return Current motion detection duration threshold value (LSB = 1ms)
    480           * @see MPU6050_RA_MOT_DUR
    481           */
    482          uint8_t MPU6050::getMotionDetectionDuration() {
    483              I2Cdev::readByte(devAddr, MPU6050_RA_MOT_DUR, buffer);
    484              return buffer[0];
    485          }
    486          /** Set motion detection event duration threshold.
    487           * @param duration New motion detection duration threshold value (LSB = 1ms)
    488           * @see getMotionDetectionDuration()
    489           * @see MPU6050_RA_MOT_DUR
    490           */
    491          void MPU6050::setMotionDetectionDuration(uint8_t duration) {
    492              I2Cdev::writeByte(devAddr, MPU6050_RA_MOT_DUR, duration);
    493          }
    494          
    495          // ZRMOT_THR register
    496          
    497          /** Get zero motion detection event acceleration threshold.
    498           * This register configures the detection threshold for Zero Motion interrupt
    499           * generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Motion is detected when
    500           * the absolute value of the accelerometer measurements for the 3 axes are each
    501           * less than the detection threshold. This condition increments the Zero Motion
    502           * duration counter (Register 34). The Zero Motion interrupt is triggered when
    503           * the Zero Motion duration counter reaches the time count specified in
    504           * ZRMOT_DUR (Register 34).
    505           *
    506           * Unlike Free Fall or Motion detection, Zero Motion detection triggers an
    507           * interrupt both when Zero Motion is first detected and when Zero Motion is no
    508           * longer detected.
    509           *
    510           * When a zero motion event is detected, a Zero Motion Status will be indicated
    511           * in the MOT_DETECT_STATUS register (Register 97). When a motion-to-zero-motion
    512           * condition is detected, the status bit is set to 1. When a zero-motion-to-
    513           * motion condition is detected, the status bit is set to 0.
    514           *
    515           * For more details on the Zero Motion detection interrupt, see Section 8.4 of
    516           * the MPU-6000/MPU-6050 Product Specification document as well as Registers 56
    517           * and 58 of this document.
    518           *
    519           * @return Current zero motion detection acceleration threshold value (LSB = 2mg)
    520           * @see MPU6050_RA_ZRMOT_THR
    521           */
    522          uint8_t MPU6050::getZeroMotionDetectionThreshold() {
    523              I2Cdev::readByte(devAddr, MPU6050_RA_ZRMOT_THR, buffer);
    524              return buffer[0];
    525          }
    526          /** Set zero motion detection event acceleration threshold.
    527           * @param threshold New zero motion detection acceleration threshold value (LSB = 2mg)
    528           * @see getZeroMotionDetectionThreshold()
    529           * @see MPU6050_RA_ZRMOT_THR
    530           */
    531          void MPU6050::setZeroMotionDetectionThreshold(uint8_t threshold) {
    532              I2Cdev::writeByte(devAddr, MPU6050_RA_ZRMOT_THR, threshold);
    533          }
    534          
    535          // ZRMOT_DUR register
    536          
    537          /** Get zero motion detection event duration threshold.
    538           * This register configures the duration counter threshold for Zero Motion
    539           * interrupt generation. The duration counter ticks at 16 Hz, therefore
    540           * ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion duration counter
    541           * increments while the absolute value of the accelerometer measurements are
    542           * each less than the detection threshold (Register 33). The Zero Motion
    543           * interrupt is triggered when the Zero Motion duration counter reaches the time
    544           * count specified in this register.
    545           *
    546           * For more details on the Zero Motion detection interrupt, see Section 8.4 of
    547           * the MPU-6000/MPU-6050 Product Specification document, as well as Registers 56
    548           * and 58 of this document.
    549           *
    550           * @return Current zero motion detection duration threshold value (LSB = 64ms)
    551           * @see MPU6050_RA_ZRMOT_DUR
    552           */
    553          uint8_t MPU6050::getZeroMotionDetectionDuration() {
    554              I2Cdev::readByte(devAddr, MPU6050_RA_ZRMOT_DUR, buffer);
    555              return buffer[0];
    556          }
    557          /** Set zero motion detection event duration threshold.
    558           * @param duration New zero motion detection duration threshold value (LSB = 1ms)
    559           * @see getZeroMotionDetectionDuration()
    560           * @see MPU6050_RA_ZRMOT_DUR
    561           */
    562          void MPU6050::setZeroMotionDetectionDuration(uint8_t duration) {
    563              I2Cdev::writeByte(devAddr, MPU6050_RA_ZRMOT_DUR, duration);
    564          }
    565          
    566          // FIFO_EN register
    567          
    568          /** Get temperature FIFO enabled value.
    569           * When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and
    570           * 66) to be written into the FIFO buffer.
    571           * @return Current temperature FIFO enabled value
    572           * @see MPU6050_RA_FIFO_EN
    573           */
    574          bool MPU6050::getTempFIFOEnabled() {
    575              I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, buffer);
    576              return buffer[0];
    577          }
    578          /** Set temperature FIFO enabled value.
    579           * @param enabled New temperature FIFO enabled value
    580           * @see getTempFIFOEnabled()
    581           * @see MPU6050_RA_FIFO_EN
    582           */
    583          void MPU6050::setTempFIFOEnabled(bool enabled) {
    584              I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, enabled);
    585          }
    586          /** Get gyroscope X-axis FIFO enabled value.
    587           * When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and
    588           * 68) to be written into the FIFO buffer.
    589           * @return Current gyroscope X-axis FIFO enabled value
    590           * @see MPU6050_RA_FIFO_EN
    591           */
    592          bool MPU6050::getXGyroFIFOEnabled() {
    593              I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, buffer);
    594              return buffer[0];
    595          }
    596          /** Set gyroscope X-axis FIFO enabled value.
    597           * @param enabled New gyroscope X-axis FIFO enabled value
    598           * @see getXGyroFIFOEnabled()
    599           * @see MPU6050_RA_FIFO_EN
    600           */
    601          void MPU6050::setXGyroFIFOEnabled(bool enabled) {
    602              I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, enabled);
    603          }
    604          /** Get gyroscope Y-axis FIFO enabled value.
    605           * When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and
    606           * 70) to be written into the FIFO buffer.
    607           * @return Current gyroscope Y-axis FIFO enabled value
    608           * @see MPU6050_RA_FIFO_EN
    609           */
    610          bool MPU6050::getYGyroFIFOEnabled() {
    611              I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, buffer);
    612              return buffer[0];
    613          }
    614          /** Set gyroscope Y-axis FIFO enabled value.
    615           * @param enabled New gyroscope Y-axis FIFO enabled value
    616           * @see getYGyroFIFOEnabled()
    617           * @see MPU6050_RA_FIFO_EN
    618           */
    619          void MPU6050::setYGyroFIFOEnabled(bool enabled) {
    620              I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, enabled);
    621          }
    622          /** Get gyroscope Z-axis FIFO enabled value.
    623           * When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and
    624           * 72) to be written into the FIFO buffer.
    625           * @return Current gyroscope Z-axis FIFO enabled value
    626           * @see MPU6050_RA_FIFO_EN
    627           */
    628          bool MPU6050::getZGyroFIFOEnabled() {
    629              I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, buffer);
    630              return buffer[0];
    631          }
    632          /** Set gyroscope Z-axis FIFO enabled value.
    633           * @param enabled New gyroscope Z-axis FIFO enabled value
    634           * @see getZGyroFIFOEnabled()
    635           * @see MPU6050_RA_FIFO_EN
    636           */
    637          void MPU6050::setZGyroFIFOEnabled(bool enabled) {
    638              I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, enabled);
    639          }
    640          /** Get accelerometer FIFO enabled value.
    641           * When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H,
    642           * ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be
    643           * written into the FIFO buffer.
    644           * @return Current accelerometer FIFO enabled value
    645           * @see MPU6050_RA_FIFO_EN
    646           */
    647          bool MPU6050::getAccelFIFOEnabled() {
    648              I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, buffer);
    649              return buffer[0];
    650          }
    651          /** Set accelerometer FIFO enabled value.
    652           * @param enabled New accelerometer FIFO enabled value
    653           * @see getAccelFIFOEnabled()
    654           * @see MPU6050_RA_FIFO_EN
    655           */
    656          void MPU6050::setAccelFIFOEnabled(bool enabled) {
    657              I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, enabled);
    658          }
    659          /** Get Slave 2 FIFO enabled value.
    660           * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)
    661           * associated with Slave 2 to be written into the FIFO buffer.
    662           * @return Current Slave 2 FIFO enabled value
    663           * @see MPU6050_RA_FIFO_EN
    664           */
    665          bool MPU6050::getSlave2FIFOEnabled() {
    666              I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV2_FIFO_EN_BIT, buffer);
    667              return buffer[0];
    668          }
    669          /** Set Slave 2 FIFO enabled value.
    670           * @param enabled New Slave 2 FIFO enabled value
    671           * @see getSlave2FIFOEnabled()
    672           * @see MPU6050_RA_FIFO_EN
    673           */
    674          void MPU6050::setSlave2FIFOEnabled(bool enabled) {
    675              I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV2_FIFO_EN_BIT, enabled);
    676          }
    677          /** Get Slave 1 FIFO enabled value.
    678           * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)
    679           * associated with Slave 1 to be written into the FIFO buffer.
    680           * @return Current Slave 1 FIFO enabled value
    681           * @see MPU6050_RA_FIFO_EN
    682           */
    683          bool MPU6050::getSlave1FIFOEnabled() {
    684              I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV1_FIFO_EN_BIT, buffer);
    685              return buffer[0];
    686          }
    687          /** Set Slave 1 FIFO enabled value.
    688           * @param enabled New Slave 1 FIFO enabled value
    689           * @see getSlave1FIFOEnabled()
    690           * @see MPU6050_RA_FIFO_EN
    691           */
    692          void MPU6050::setSlave1FIFOEnabled(bool enabled) {
    693              I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV1_FIFO_EN_BIT, enabled);
    694          }
    695          /** Get Slave 0 FIFO enabled value.
    696           * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)
    697           * associated with Slave 0 to be written into the FIFO buffer.
    698           * @return Current Slave 0 FIFO enabled value
    699           * @see MPU6050_RA_FIFO_EN
    700           */
    701          bool MPU6050::getSlave0FIFOEnabled() {
    702              I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV0_FIFO_EN_BIT, buffer);
    703              return buffer[0];
    704          }
    705          /** Set Slave 0 FIFO enabled value.
    706           * @param enabled New Slave 0 FIFO enabled value
    707           * @see getSlave0FIFOEnabled()
    708           * @see MPU6050_RA_FIFO_EN
    709           */
    710          void MPU6050::setSlave0FIFOEnabled(bool enabled) {
    711              I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV0_FIFO_EN_BIT, enabled);
    712          }
    713          
    714          // I2C_MST_CTRL register
    715          
    716          /** Get multi-master enabled value.
    717           * Multi-master capability allows multiple I2C masters to operate on the same
    718           * bus. In circuits where multi-master capability is required, set MULT_MST_EN
    719           * to 1. This will increase current drawn by approximately 30uA.
    720           *
    721           * In circuits where multi-master capability is required, the state of the I2C
    722           * bus must always be monitored by each separate I2C Master. Before an I2C
    723           * Master can assume arbitration of the bus, it must first confirm that no other
    724           * I2C Master has arbitration of the bus. When MULT_MST_EN is set to 1, the
    725           * MPU-60X0's bus arbitration detection logic is turned on, enabling it to
    726           * detect when the bus is available.
    727           *
    728           * @return Current multi-master enabled value
    729           * @see MPU6050_RA_I2C_MST_CTRL
    730           */
    731          bool MPU6050::getMultiMasterEnabled() {
    732              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_MULT_MST_EN_BIT, buffer);
    733              return buffer[0];
    734          }
    735          /** Set multi-master enabled value.
    736           * @param enabled New multi-master enabled value
    737           * @see getMultiMasterEnabled()
    738           * @see MPU6050_RA_I2C_MST_CTRL
    739           */
    740          void MPU6050::setMultiMasterEnabled(bool enabled) {
    741              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_MULT_MST_EN_BIT, enabled);
    742          }
    743          /** Get wait-for-external-sensor-data enabled value.
    744           * When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be
    745           * delayed until External Sensor data from the Slave Devices are loaded into the
    746           * EXT_SENS_DATA registers. This is used to ensure that both the internal sensor
    747           * data (i.e. from gyro and accel) and external sensor data have been loaded to
    748           * their respective data registers (i.e. the data is synced) when the Data Ready
    749           * interrupt is triggered.
    750           *
    751           * @return Current wait-for-external-sensor-data enabled value
    752           * @see MPU6050_RA_I2C_MST_CTRL
    753           */
    754          bool MPU6050::getWaitForExternalSensorEnabled() {
    755              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_WAIT_FOR_ES_BIT, buffer);
    756              return buffer[0];
    757          }
    758          /** Set wait-for-external-sensor-data enabled value.
    759           * @param enabled New wait-for-external-sensor-data enabled value
    760           * @see getWaitForExternalSensorEnabled()
    761           * @see MPU6050_RA_I2C_MST_CTRL
    762           */
    763          void MPU6050::setWaitForExternalSensorEnabled(bool enabled) {
    764              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_WAIT_FOR_ES_BIT, enabled);
    765          }
    766          /** Get Slave 3 FIFO enabled value.
    767           * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)
    768           * associated with Slave 3 to be written into the FIFO buffer.
    769           * @return Current Slave 3 FIFO enabled value
    770           * @see MPU6050_RA_MST_CTRL
    771           */
    772          bool MPU6050::getSlave3FIFOEnabled() {
    773              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_SLV_3_FIFO_EN_BIT, buffer);
    774              return buffer[0];
    775          }
    776          /** Set Slave 3 FIFO enabled value.
    777           * @param enabled New Slave 3 FIFO enabled value
    778           * @see getSlave3FIFOEnabled()
    779           * @see MPU6050_RA_MST_CTRL
    780           */
    781          void MPU6050::setSlave3FIFOEnabled(bool enabled) {
    782              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_SLV_3_FIFO_EN_BIT, enabled);
    783          }
    784          /** Get slave read/write transition enabled value.
    785           * The I2C_MST_P_NSR bit configures the I2C Master's transition from one slave
    786           * read to the next slave read. If the bit equals 0, there will be a restart
    787           * between reads. If the bit equals 1, there will be a stop followed by a start
    788           * of the following read. When a write transaction follows a read transaction,
    789           * the stop followed by a start of the successive write will be always used.
    790           *
    791           * @return Current slave read/write transition enabled value
    792           * @see MPU6050_RA_I2C_MST_CTRL
    793           */
    794          bool MPU6050::getSlaveReadWriteTransitionEnabled() {
    795              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_P_NSR_BIT, buffer);
    796              return buffer[0];
    797          }
    798          /** Set slave read/write transition enabled value.
    799           * @param enabled New slave read/write transition enabled value
    800           * @see getSlaveReadWriteTransitionEnabled()
    801           * @see MPU6050_RA_I2C_MST_CTRL
    802           */
    803          void MPU6050::setSlaveReadWriteTransitionEnabled(bool enabled) {
    804              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_P_NSR_BIT, enabled);
    805          }
    806          /** Get I2C master clock speed.
    807           * I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the
    808           * MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to
    809           * the following table:
    810           *
    811           * <pre>
    812           * I2C_MST_CLK | I2C Master Clock Speed | 8MHz Clock Divider
    813           * ------------+------------------------+-------------------
    814           * 0           | 348kHz                 | 23
    815           * 1           | 333kHz                 | 24
    816           * 2           | 320kHz                 | 25
    817           * 3           | 308kHz                 | 26
    818           * 4           | 296kHz                 | 27
    819           * 5           | 286kHz                 | 28
    820           * 6           | 276kHz                 | 29
    821           * 7           | 267kHz                 | 30
    822           * 8           | 258kHz                 | 31
    823           * 9           | 500kHz                 | 16
    824           * 10          | 471kHz                 | 17
    825           * 11          | 444kHz                 | 18
    826           * 12          | 421kHz                 | 19
    827           * 13          | 400kHz                 | 20
    828           * 14          | 381kHz                 | 21
    829           * 15          | 364kHz                 | 22
    830           * </pre>
    831           *
    832           * @return Current I2C master clock speed
    833           * @see MPU6050_RA_I2C_MST_CTRL
    834           */
    835          uint8_t MPU6050::getMasterClockSpeed() {
    836              I2Cdev::readBits(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_CLK_BIT, MPU6050_I2C_MST_CLK_LENGTH, buffer);
    837              return buffer[0];
    838          }
    839          /** Set I2C master clock speed.
    840           * @reparam speed Current I2C master clock speed
    841           * @see MPU6050_RA_I2C_MST_CTRL
    842           */
    843          void MPU6050::setMasterClockSpeed(uint8_t speed) {
    844              I2Cdev::writeBits(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_CLK_BIT, MPU6050_I2C_MST_CLK_LENGTH, speed);
    845          }
    846          
    847          // I2C_SLV* registers (Slave 0-3)
    848          
    849          /** Get the I2C address of the specified slave (0-3).
    850           * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read
    851           * operation, and if it is cleared, then it's a write operation. The remaining
    852           * bits (6-0) are the 7-bit device address of the slave device.
    853           *
    854           * In read mode, the result of the read is placed in the lowest available 
    855           * EXT_SENS_DATA register. For further information regarding the allocation of
    856           * read results, please refer to the EXT_SENS_DATA register description
    857           * (Registers 73 - 96).
    858           *
    859           * The MPU-6050 supports a total of five slaves, but Slave 4 has unique
    860           * characteristics, and so it has its own functions (getSlave4* and setSlave4*).
    861           *
    862           * I2C data transactions are performed at the Sample Rate, as defined in
    863           * Register 25. The user is responsible for ensuring that I2C data transactions
    864           * to and from each enabled Slave can be completed within a single period of the
    865           * Sample Rate.
    866           *
    867           * The I2C slave access rate can be reduced relative to the Sample Rate. This
    868           * reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a
    869           * slave's access rate is reduced relative to the Sample Rate is determined by
    870           * I2C_MST_DELAY_CTRL (Register 103).
    871           *
    872           * The processing order for the slaves is fixed. The sequence followed for
    873           * processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a
    874           * particular Slave is disabled it will be skipped.
    875           *
    876           * Each slave can either be accessed at the sample rate or at a reduced sample
    877           * rate. In a case where some slaves are accessed at the Sample Rate and some
    878           * slaves are accessed at the reduced rate, the sequence of accessing the slaves
    879           * (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will
    880           * be skipped if their access rate dictates that they should not be accessed
    881           * during that particular cycle. For further information regarding the reduced
    882           * access rate, please refer to Register 52. Whether a slave is accessed at the
    883           * Sample Rate or at the reduced rate is determined by the Delay Enable bits in
    884           * Register 103.
    885           *
    886           * @param num Slave number (0-3)
    887           * @return Current address for specified slave
    888           * @see MPU6050_RA_I2C_SLV0_ADDR
    889           */
    890          uint8_t MPU6050::getSlaveAddress(uint8_t num) {
    891              if (num > 3) return 0;
    892              I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV0_ADDR + num*3, buffer);
    893              return buffer[0];
    894          }
    895          /** Set the I2C address of the specified slave (0-3).
    896           * @param num Slave number (0-3)
    897           * @param address New address for specified slave
    898           * @see getSlaveAddress()
    899           * @see MPU6050_RA_I2C_SLV0_ADDR
    900           */
    901          void MPU6050::setSlaveAddress(uint8_t num, uint8_t address) {
    902              if (num > 3) return;
    903              I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_ADDR + num*3, address);
    904          }
    905          /** Get the active internal register for the specified slave (0-3).
    906           * Read/write operations for this slave will be done to whatever internal
    907           * register address is stored in this MPU register.
    908           *
    909           * The MPU-6050 supports a total of five slaves, but Slave 4 has unique
    910           * characteristics, and so it has its own functions.
    911           *
    912           * @param num Slave number (0-3)
    913           * @return Current active register for specified slave
    914           * @see MPU6050_RA_I2C_SLV0_REG
    915           */
    916          uint8_t MPU6050::getSlaveRegister(uint8_t num) {
    917              if (num > 3) return 0;
    918              I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV0_REG + num*3, buffer);
    919              return buffer[0];
    920          }
    921          /** Set the active internal register for the specified slave (0-3).
    922           * @param num Slave number (0-3)
    923           * @param reg New active register for specified slave
    924           * @see getSlaveRegister()
    925           * @see MPU6050_RA_I2C_SLV0_REG
    926           */
    927          void MPU6050::setSlaveRegister(uint8_t num, uint8_t reg) {
    928              if (num > 3) return;
    929              I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_REG + num*3, reg);
    930          }
    931          /** Get the enabled value for the specified slave (0-3).
    932           * When set to 1, this bit enables Slave 0 for data transfer operations. When
    933           * cleared to 0, this bit disables Slave 0 from data transfer operations.
    934           * @param num Slave number (0-3)
    935           * @return Current enabled value for specified slave
    936           * @see MPU6050_RA_I2C_SLV0_CTRL
    937           */
    938          bool MPU6050::getSlaveEnabled(uint8_t num) {
    939              if (num > 3) return 0;
    940              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_EN_BIT, buffer);
    941              return buffer[0];
    942          }
    943          /** Set the enabled value for the specified slave (0-3).
    944           * @param num Slave number (0-3)
    945           * @param enabled New enabled value for specified slave
    946           * @see getSlaveEnabled()
    947           * @see MPU6050_RA_I2C_SLV0_CTRL
    948           */
    949          void MPU6050::setSlaveEnabled(uint8_t num, bool enabled) {
    950              if (num > 3) return;
    951              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_EN_BIT, enabled);
    952          }
    953          /** Get word pair byte-swapping enabled for the specified slave (0-3).
    954           * When set to 1, this bit enables byte swapping. When byte swapping is enabled,
    955           * the high and low bytes of a word pair are swapped. Please refer to
    956           * I2C_SLV0_GRP for the pairing convention of the word pairs. When cleared to 0,
    957           * bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA
    958           * registers in the order they were transferred.
    959           *
    960           * @param num Slave number (0-3)
    961           * @return Current word pair byte-swapping enabled value for specified slave
    962           * @see MPU6050_RA_I2C_SLV0_CTRL
    963           */
    964          bool MPU6050::getSlaveWordByteSwap(uint8_t num) {
    965              if (num > 3) return 0;
    966              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_BYTE_SW_BIT, buffer);
    967              return buffer[0];
    968          }
    969          /** Set word pair byte-swapping enabled for the specified slave (0-3).
    970           * @param num Slave number (0-3)
    971           * @param enabled New word pair byte-swapping enabled value for specified slave
    972           * @see getSlaveWordByteSwap()
    973           * @see MPU6050_RA_I2C_SLV0_CTRL
    974           */
    975          void MPU6050::setSlaveWordByteSwap(uint8_t num, bool enabled) {
    976              if (num > 3) return;
    977              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_BYTE_SW_BIT, enabled);
    978          }
    979          /** Get write mode for the specified slave (0-3).
    980           * When set to 1, the transaction will read or write data only. When cleared to
    981           * 0, the transaction will write a register address prior to reading or writing
    982           * data. This should equal 0 when specifying the register address within the
    983           * Slave device to/from which the ensuing data transaction will take place.
    984           *
    985           * @param num Slave number (0-3)
    986           * @return Current write mode for specified slave (0 = register address + data, 1 = data only)
    987           * @see MPU6050_RA_I2C_SLV0_CTRL
    988           */
    989          bool MPU6050::getSlaveWriteMode(uint8_t num) {
    990              if (num > 3) return 0;
    991              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_REG_DIS_BIT, buffer);
    992              return buffer[0];
    993          }
    994          /** Set write mode for the specified slave (0-3).
    995           * @param num Slave number (0-3)
    996           * @param mode New write mode for specified slave (0 = register address + data, 1 = data only)
    997           * @see getSlaveWriteMode()
    998           * @see MPU6050_RA_I2C_SLV0_CTRL
    999           */
   1000          void MPU6050::setSlaveWriteMode(uint8_t num, bool mode) {
   1001              if (num > 3) return;
   1002              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_REG_DIS_BIT, mode);
   1003          }
   1004          /** Get word pair grouping order offset for the specified slave (0-3).
   1005           * This sets specifies the grouping order of word pairs received from registers.
   1006           * When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even,
   1007           * then odd register addresses) are paired to form a word. When set to 1, bytes
   1008           * from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even
   1009           * register addresses) are paired to form a word.
   1010           *
   1011           * @param num Slave number (0-3)
   1012           * @return Current word pair grouping order offset for specified slave
   1013           * @see MPU6050_RA_I2C_SLV0_CTRL
   1014           */
   1015          bool MPU6050::getSlaveWordGroupOffset(uint8_t num) {
   1016              if (num > 3) return 0;
   1017              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_GRP_BIT, buffer);
   1018              return buffer[0];
   1019          }
   1020          /** Set word pair grouping order offset for the specified slave (0-3).
   1021           * @param num Slave number (0-3)
   1022           * @param enabled New word pair grouping order offset for specified slave
   1023           * @see getSlaveWordGroupOffset()
   1024           * @see MPU6050_RA_I2C_SLV0_CTRL
   1025           */
   1026          void MPU6050::setSlaveWordGroupOffset(uint8_t num, bool enabled) {
   1027              if (num > 3) return;
   1028              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_GRP_BIT, enabled);
   1029          }
   1030          /** Get number of bytes to read for the specified slave (0-3).
   1031           * Specifies the number of bytes transferred to and from Slave 0. Clearing this
   1032           * bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN.
   1033           * @param num Slave number (0-3)
   1034           * @return Number of bytes to read for specified slave
   1035           * @see MPU6050_RA_I2C_SLV0_CTRL
   1036           */
   1037          uint8_t MPU6050::getSlaveDataLength(uint8_t num) {
   1038              if (num > 3) return 0;
   1039              I2Cdev::readBits(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_LEN_BIT, MPU6050_I2C_SLV_LEN_LENGTH, buffer);
   1040              return buffer[0];
   1041          }
   1042          /** Set number of bytes to read for the specified slave (0-3).
   1043           * @param num Slave number (0-3)
   1044           * @param length Number of bytes to read for specified slave
   1045           * @see getSlaveDataLength()
   1046           * @see MPU6050_RA_I2C_SLV0_CTRL
   1047           */
   1048          void MPU6050::setSlaveDataLength(uint8_t num, uint8_t length) {
   1049              if (num > 3) return;
   1050              I2Cdev::writeBits(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_LEN_BIT, MPU6050_I2C_SLV_LEN_LENGTH, length);
   1051          }
   1052          
   1053          // I2C_SLV* registers (Slave 4)
   1054          
   1055          /** Get the I2C address of Slave 4.
   1056           * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read
   1057           * operation, and if it is cleared, then it's a write operation. The remaining
   1058           * bits (6-0) are the 7-bit device address of the slave device.
   1059           *
   1060           * @return Current address for Slave 4
   1061           * @see getSlaveAddress()
   1062           * @see MPU6050_RA_I2C_SLV4_ADDR
   1063           */
   1064          uint8_t MPU6050::getSlave4Address() {
   1065              I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV4_ADDR, buffer);
   1066              return buffer[0];
   1067          }
   1068          /** Set the I2C address of Slave 4.
   1069           * @param address New address for Slave 4
   1070           * @see getSlave4Address()
   1071           * @see MPU6050_RA_I2C_SLV4_ADDR
   1072           */
   1073          void MPU6050::setSlave4Address(uint8_t address) {
   1074              I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV4_ADDR, address);
   1075          }
   1076          /** Get the active internal register for the Slave 4.
   1077           * Read/write operations for this slave will be done to whatever internal
   1078           * register address is stored in this MPU register.
   1079           *
   1080           * @return Current active register for Slave 4
   1081           * @see MPU6050_RA_I2C_SLV4_REG
   1082           */
   1083          uint8_t MPU6050::getSlave4Register() {
   1084              I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV4_REG, buffer);
   1085              return buffer[0];
   1086          }
   1087          /** Set the active internal register for Slave 4.
   1088           * @param reg New active register for Slave 4
   1089           * @see getSlave4Register()
   1090           * @see MPU6050_RA_I2C_SLV4_REG
   1091           */
   1092          void MPU6050::setSlave4Register(uint8_t reg) {
   1093              I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV4_REG, reg);
   1094          }
   1095          /** Set new byte to write to Slave 4.
   1096           * This register stores the data to be written into the Slave 4. If I2C_SLV4_RW
   1097           * is set 1 (set to read), this register has no effect.
   1098           * @param data New byte to write to Slave 4
   1099           * @see MPU6050_RA_I2C_SLV4_DO
   1100           */
   1101          void MPU6050::setSlave4OutputByte(uint8_t data) {
   1102              I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV4_DO, data);
   1103          }
   1104          /** Get the enabled value for the Slave 4.
   1105           * When set to 1, this bit enables Slave 4 for data transfer operations. When
   1106           * cleared to 0, this bit disables Slave 4 from data transfer operations.
   1107           * @return Current enabled value for Slave 4
   1108           * @see MPU6050_RA_I2C_SLV4_CTRL
   1109           */
   1110          bool MPU6050::getSlave4Enabled() {
   1111              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_EN_BIT, buffer);
   1112              return buffer[0];
   1113          }
   1114          /** Set the enabled value for Slave 4.
   1115           * @param enabled New enabled value for Slave 4
   1116           * @see getSlave4Enabled()
   1117           * @see MPU6050_RA_I2C_SLV4_CTRL
   1118           */
   1119          void MPU6050::setSlave4Enabled(bool enabled) {
   1120              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_EN_BIT, enabled);
   1121          }
   1122          /** Get the enabled value for Slave 4 transaction interrupts.
   1123           * When set to 1, this bit enables the generation of an interrupt signal upon
   1124           * completion of a Slave 4 transaction. When cleared to 0, this bit disables the
   1125           * generation of an interrupt signal upon completion of a Slave 4 transaction.
   1126           * The interrupt status can be observed in Register 54.
   1127           *
   1128           * @return Current enabled value for Slave 4 transaction interrupts.
   1129           * @see MPU6050_RA_I2C_SLV4_CTRL
   1130           */
   1131          bool MPU6050::getSlave4InterruptEnabled() {
   1132              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_INT_EN_BIT, buffer);
   1133              return buffer[0];
   1134          }
   1135          /** Set the enabled value for Slave 4 transaction interrupts.
   1136           * @param enabled New enabled value for Slave 4 transaction interrupts.
   1137           * @see getSlave4InterruptEnabled()
   1138           * @see MPU6050_RA_I2C_SLV4_CTRL
   1139           */
   1140          void MPU6050::setSlave4InterruptEnabled(bool enabled) {
   1141              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_INT_EN_BIT, enabled);
   1142          }
   1143          /** Get write mode for Slave 4.
   1144           * When set to 1, the transaction will read or write data only. When cleared to
   1145           * 0, the transaction will write a register address prior to reading or writing
   1146           * data. This should equal 0 when specifying the register address within the
   1147           * Slave device to/from which the ensuing data transaction will take place.
   1148           *
   1149           * @return Current write mode for Slave 4 (0 = register address + data, 1 = data only)
   1150           * @see MPU6050_RA_I2C_SLV4_CTRL
   1151           */
   1152          bool MPU6050::getSlave4WriteMode() {
   1153              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_REG_DIS_BIT, buffer);
   1154              return buffer[0];
   1155          }
   1156          /** Set write mode for the Slave 4.
   1157           * @param mode New write mode for Slave 4 (0 = register address + data, 1 = data only)
   1158           * @see getSlave4WriteMode()
   1159           * @see MPU6050_RA_I2C_SLV4_CTRL
   1160           */
   1161          void MPU6050::setSlave4WriteMode(bool mode) {
   1162              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_REG_DIS_BIT, mode);
   1163          }
   1164          /** Get Slave 4 master delay value.
   1165           * This configures the reduced access rate of I2C slaves relative to the Sample
   1166           * Rate. When a slave's access rate is decreased relative to the Sample Rate,
   1167           * the slave is accessed every:
   1168           *
   1169           *     1 / (1 + I2C_MST_DLY) samples
   1170           *
   1171           * This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and
   1172           * DLPF_CFG (register 26). Whether a slave's access rate is reduced relative to
   1173           * the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103). For
   1174           * further information regarding the Sample Rate, please refer to register 25.
   1175           *
   1176           * @return Current Slave 4 master delay value
   1177           * @see MPU6050_RA_I2C_SLV4_CTRL
   1178           */
   1179          uint8_t MPU6050::getSlave4MasterDelay() {
   1180              I2Cdev::readBits(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_MST_DLY_BIT, MPU6050_I2C_SLV4_MST_DLY_LENGTH, buffer);
   1181              return buffer[0];
   1182          }
   1183          /** Set Slave 4 master delay value.
   1184           * @param delay New Slave 4 master delay value
   1185           * @see getSlave4MasterDelay()
   1186           * @see MPU6050_RA_I2C_SLV4_CTRL
   1187           */
   1188          void MPU6050::setSlave4MasterDelay(uint8_t delay) {
   1189              I2Cdev::writeBits(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_MST_DLY_BIT, MPU6050_I2C_SLV4_MST_DLY_LENGTH, delay);
   1190          }
   1191          /** Get last available byte read from Slave 4.
   1192           * This register stores the data read from Slave 4. This field is populated
   1193           * after a read transaction.
   1194           * @return Last available byte read from to Slave 4
   1195           * @see MPU6050_RA_I2C_SLV4_DI
   1196           */
   1197          uint8_t MPU6050::getSlate4InputByte() {
   1198              I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV4_DI, buffer);
   1199              return buffer[0];
   1200          }
   1201          
   1202          // I2C_MST_STATUS register
   1203          
   1204          /** Get FSYNC interrupt status.
   1205           * This bit reflects the status of the FSYNC interrupt from an external device
   1206           * into the MPU-60X0. This is used as a way to pass an external interrupt
   1207           * through the MPU-60X0 to the host application processor. When set to 1, this
   1208           * bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG
   1209           * (Register 55).
   1210           * @return FSYNC interrupt status
   1211           * @see MPU6050_RA_I2C_MST_STATUS
   1212           */
   1213          bool MPU6050::getPassthroughStatus() {
   1214              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_PASS_THROUGH_BIT, buffer);
   1215              return buffer[0];
   1216          }
   1217          /** Get Slave 4 transaction done status.
   1218           * Automatically sets to 1 when a Slave 4 transaction has completed. This
   1219           * triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register
   1220           * (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the
   1221           * I2C_SLV4_CTRL register (Register 52).
   1222           * @return Slave 4 transaction done status
   1223           * @see MPU6050_RA_I2C_MST_STATUS
   1224           */
   1225          bool MPU6050::getSlave4IsDone() {
   1226              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV4_DONE_BIT, buffer);
   1227              return buffer[0];
   1228          }
   1229          /** Get master arbitration lost status.
   1230           * This bit automatically sets to 1 when the I2C Master has lost arbitration of
   1231           * the auxiliary I2C bus (an error condition). This triggers an interrupt if the
   1232           * I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.
   1233           * @return Master arbitration lost status
   1234           * @see MPU6050_RA_I2C_MST_STATUS
   1235           */
   1236          bool MPU6050::getLostArbitration() {
   1237              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_LOST_ARB_BIT, buffer);
   1238              return buffer[0];
   1239          }
   1240          /** Get Slave 4 NACK status.
   1241           * This bit automatically sets to 1 when the I2C Master receives a NACK in a
   1242           * transaction with Slave 4. This triggers an interrupt if the I2C_MST_INT_EN
   1243           * bit in the INT_ENABLE register (Register 56) is asserted.
   1244           * @return Slave 4 NACK interrupt status
   1245           * @see MPU6050_RA_I2C_MST_STATUS
   1246           */
   1247          bool MPU6050::getSlave4Nack() {
   1248              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV4_NACK_BIT, buffer);
   1249              return buffer[0];
   1250          }
   1251          /** Get Slave 3 NACK status.
   1252           * This bit automatically sets to 1 when the I2C Master receives a NACK in a
   1253           * transaction with Slave 3. This triggers an interrupt if the I2C_MST_INT_EN
   1254           * bit in the INT_ENABLE register (Register 56) is asserted.
   1255           * @return Slave 3 NACK interrupt status
   1256           * @see MPU6050_RA_I2C_MST_STATUS
   1257           */
   1258          bool MPU6050::getSlave3Nack() {
   1259              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV3_NACK_BIT, buffer);
   1260              return buffer[0];
   1261          }
   1262          /** Get Slave 2 NACK status.
   1263           * This bit automatically sets to 1 when the I2C Master receives a NACK in a
   1264           * transaction with Slave 2. This triggers an interrupt if the I2C_MST_INT_EN
   1265           * bit in the INT_ENABLE register (Register 56) is asserted.
   1266           * @return Slave 2 NACK interrupt status
   1267           * @see MPU6050_RA_I2C_MST_STATUS
   1268           */
   1269          bool MPU6050::getSlave2Nack() {
   1270              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV2_NACK_BIT, buffer);
   1271              return buffer[0];
   1272          }
   1273          /** Get Slave 1 NACK status.
   1274           * This bit automatically sets to 1 when the I2C Master receives a NACK in a
   1275           * transaction with Slave 1. This triggers an interrupt if the I2C_MST_INT_EN
   1276           * bit in the INT_ENABLE register (Register 56) is asserted.
   1277           * @return Slave 1 NACK interrupt status
   1278           * @see MPU6050_RA_I2C_MST_STATUS
   1279           */
   1280          bool MPU6050::getSlave1Nack() {
   1281              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV1_NACK_BIT, buffer);
   1282              return buffer[0];
   1283          }
   1284          /** Get Slave 0 NACK status.
   1285           * This bit automatically sets to 1 when the I2C Master receives a NACK in a
   1286           * transaction with Slave 0. This triggers an interrupt if the I2C_MST_INT_EN
   1287           * bit in the INT_ENABLE register (Register 56) is asserted.
   1288           * @return Slave 0 NACK interrupt status
   1289           * @see MPU6050_RA_I2C_MST_STATUS
   1290           */
   1291          bool MPU6050::getSlave0Nack() {
   1292              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV0_NACK_BIT, buffer);
   1293              return buffer[0];
   1294          }
   1295          
   1296          // INT_PIN_CFG register
   1297          
   1298          /** Get interrupt logic level mode.
   1299           * Will be set 0 for active-high, 1 for active-low.
   1300           * @return Current interrupt mode (0=active-high, 1=active-low)
   1301           * @see MPU6050_RA_INT_PIN_CFG
   1302           * @see MPU6050_INTCFG_INT_LEVEL_BIT
   1303           */
   1304          bool MPU6050::getInterruptMode() {
   1305              I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, buffer);
   1306              return buffer[0];
   1307          }
   1308          /** Set interrupt logic level mode.
   1309           * @param mode New interrupt mode (0=active-high, 1=active-low)
   1310           * @see getInterruptMode()
   1311           * @see MPU6050_RA_INT_PIN_CFG
   1312           * @see MPU6050_INTCFG_INT_LEVEL_BIT
   1313           */
   1314          void MPU6050::setInterruptMode(bool mode) {
   1315             I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, mode);
   1316          }
   1317          /** Get interrupt drive mode.
   1318           * Will be set 0 for push-pull, 1 for open-drain.
   1319           * @return Current interrupt drive mode (0=push-pull, 1=open-drain)
   1320           * @see MPU6050_RA_INT_PIN_CFG
   1321           * @see MPU6050_INTCFG_INT_OPEN_BIT
   1322           */
   1323          bool MPU6050::getInterruptDrive() {
   1324              I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, buffer);
   1325              return buffer[0];
   1326          }
   1327          /** Set interrupt drive mode.
   1328           * @param drive New interrupt drive mode (0=push-pull, 1=open-drain)
   1329           * @see getInterruptDrive()
   1330           * @see MPU6050_RA_INT_PIN_CFG
   1331           * @see MPU6050_INTCFG_INT_OPEN_BIT
   1332           */
   1333          void MPU6050::setInterruptDrive(bool drive) {
   1334              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, drive);
   1335          }
   1336          /** Get interrupt latch mode.
   1337           * Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared.
   1338           * @return Current latch mode (0=50us-pulse, 1=latch-until-int-cleared)
   1339           * @see MPU6050_RA_INT_PIN_CFG
   1340           * @see MPU6050_INTCFG_LATCH_INT_EN_BIT
   1341           */
   1342          bool MPU6050::getInterruptLatch() {
   1343              I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, buffer);
   1344              return buffer[0];
   1345          }
   1346          /** Set interrupt latch mode.
   1347           * @param latch New latch mode (0=50us-pulse, 1=latch-until-int-cleared)
   1348           * @see getInterruptLatch()
   1349           * @see MPU6050_RA_INT_PIN_CFG
   1350           * @see MPU6050_INTCFG_LATCH_INT_EN_BIT
   1351           */
   1352          void MPU6050::setInterruptLatch(bool latch) {
   1353              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, latch);
   1354          }
   1355          /** Get interrupt latch clear mode.
   1356           * Will be set 0 for status-read-only, 1 for any-register-read.
   1357           * @return Current latch clear mode (0=status-read-only, 1=any-register-read)
   1358           * @see MPU6050_RA_INT_PIN_CFG
   1359           * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT
   1360           */
   1361          bool MPU6050::getInterruptLatchClear() {
   1362              I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_RD_CLEAR_BIT, buffer);
   1363              return buffer[0];
   1364          }
   1365          /** Set interrupt latch clear mode.
   1366           * @param clear New latch clear mode (0=status-read-only, 1=any-register-read)
   1367           * @see getInterruptLatchClear()
   1368           * @see MPU6050_RA_INT_PIN_CFG
   1369           * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT
   1370           */
   1371          void MPU6050::setInterruptLatchClear(bool clear) {
   1372              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_RD_CLEAR_BIT, clear);
   1373          }
   1374          /** Get FSYNC interrupt logic level mode.
   1375           * @return Current FSYNC interrupt mode (0=active-high, 1=active-low)
   1376           * @see getFSyncInterruptMode()
   1377           * @see MPU6050_RA_INT_PIN_CFG
   1378           * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT
   1379           */
   1380          bool MPU6050::getFSyncInterruptLevel() {
   1381              I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT, buffer);
   1382              return buffer[0];
   1383          }
   1384          /** Set FSYNC interrupt logic level mode.
   1385           * @param mode New FSYNC interrupt mode (0=active-high, 1=active-low)
   1386           * @see getFSyncInterruptMode()
   1387           * @see MPU6050_RA_INT_PIN_CFG
   1388           * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT
   1389           */
   1390          void MPU6050::setFSyncInterruptLevel(bool level) {
   1391              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT, level);
   1392          }
   1393          /** Get FSYNC pin interrupt enabled setting.
   1394           * Will be set 0 for disabled, 1 for enabled.
   1395           * @return Current interrupt enabled setting
   1396           * @see MPU6050_RA_INT_PIN_CFG
   1397           * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT
   1398           */
   1399          bool MPU6050::getFSyncInterruptEnabled() {
   1400              I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_EN_BIT, buffer);
   1401              return buffer[0];
   1402          }
   1403          /** Set FSYNC pin interrupt enabled setting.
   1404           * @param enabled New FSYNC pin interrupt enabled setting
   1405           * @see getFSyncInterruptEnabled()
   1406           * @see MPU6050_RA_INT_PIN_CFG
   1407           * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT
   1408           */
   1409          void MPU6050::setFSyncInterruptEnabled(bool enabled) {
   1410              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_EN_BIT, enabled);
   1411          }
   1412          /** Get I2C bypass enabled status.
   1413           * When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to
   1414           * 0, the host application processor will be able to directly access the
   1415           * auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host
   1416           * application processor will not be able to directly access the auxiliary I2C
   1417           * bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106
   1418           * bit[5]).
   1419           * @return Current I2C bypass enabled status
   1420           * @see MPU6050_RA_INT_PIN_CFG
   1421           * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT
   1422           */
   1423          bool MPU6050::getI2CBypassEnabled() {
   1424              I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, buffer);
   1425              return buffer[0];
   1426          }
   1427          /** Set I2C bypass enabled status.
   1428           * When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to
   1429           * 0, the host application processor will be able to directly access the
   1430           * auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host
   1431           * application processor will not be able to directly access the auxiliary I2C
   1432           * bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106
   1433           * bit[5]).
   1434           * @param enabled New I2C bypass enabled status
   1435           * @see MPU6050_RA_INT_PIN_CFG
   1436           * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT
   1437           */
   1438          void MPU6050::setI2CBypassEnabled(bool enabled) {
   1439              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, enabled);
   1440          }
   1441          /** Get reference clock output enabled status.
   1442           * When this bit is equal to 1, a reference clock output is provided at the
   1443           * CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For
   1444           * further information regarding CLKOUT, please refer to the MPU-60X0 Product
   1445           * Specification document.
   1446           * @return Current reference clock output enabled status
   1447           * @see MPU6050_RA_INT_PIN_CFG
   1448           * @see MPU6050_INTCFG_CLKOUT_EN_BIT
   1449           */
   1450          bool MPU6050::getClockOutputEnabled() {
   1451              I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_CLKOUT_EN_BIT, buffer);
   1452              return buffer[0];
   1453          }
   1454          /** Set reference clock output enabled status.
   1455           * When this bit is equal to 1, a reference clock output is provided at the
   1456           * CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For
   1457           * further information regarding CLKOUT, please refer to the MPU-60X0 Product
   1458           * Specification document.
   1459           * @param enabled New reference clock output enabled status
   1460           * @see MPU6050_RA_INT_PIN_CFG
   1461           * @see MPU6050_INTCFG_CLKOUT_EN_BIT
   1462           */
   1463          void MPU6050::setClockOutputEnabled(bool enabled) {
   1464              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_CLKOUT_EN_BIT, enabled);
   1465          }
   1466          
   1467          // INT_ENABLE register
   1468          
   1469          /** Get full interrupt enabled status.
   1470           * Full register byte for all interrupts, for quick reading. Each bit will be
   1471           * set 0 for disabled, 1 for enabled.
   1472           * @return Current interrupt enabled status
   1473           * @see MPU6050_RA_INT_ENABLE
   1474           * @see MPU6050_INTERRUPT_FF_BIT
   1475           **/
   1476          uint8_t MPU6050::getIntEnabled() {
   1477              I2Cdev::readByte(devAddr, MPU6050_RA_INT_ENABLE, buffer);
   1478              return buffer[0];
   1479          }
   1480          /** Set full interrupt enabled status.
   1481           * Full register byte for all interrupts, for quick reading. Each bit should be
   1482           * set 0 for disabled, 1 for enabled.
   1483           * @param enabled New interrupt enabled status
   1484           * @see getIntFreefallEnabled()
   1485           * @see MPU6050_RA_INT_ENABLE
   1486           * @see MPU6050_INTERRUPT_FF_BIT
   1487           **/
   1488          void MPU6050::setIntEnabled(uint8_t enabled) {
   1489              I2Cdev::writeByte(devAddr, MPU6050_RA_INT_ENABLE, enabled);
   1490          }
   1491          /** Get Free Fall interrupt enabled status.
   1492           * Will be set 0 for disabled, 1 for enabled.
   1493           * @return Current interrupt enabled status
   1494           * @see MPU6050_RA_INT_ENABLE
   1495           * @see MPU6050_INTERRUPT_FF_BIT
   1496           **/
   1497          bool MPU6050::getIntFreefallEnabled() {
   1498              I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FF_BIT, buffer);
   1499              return buffer[0];
   1500          }
   1501          /** Set Free Fall interrupt enabled status.
   1502           * @param enabled New interrupt enabled status
   1503           * @see getIntFreefallEnabled()
   1504           * @see MPU6050_RA_INT_ENABLE
   1505           * @see MPU6050_INTERRUPT_FF_BIT
   1506           **/
   1507          void MPU6050::setIntFreefallEnabled(bool enabled) {
   1508              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FF_BIT, enabled);
   1509          }
   1510          /** Get Motion Detection interrupt enabled status.
   1511           * Will be set 0 for disabled, 1 for enabled.
   1512           * @return Current interrupt enabled status
   1513           * @see MPU6050_RA_INT_ENABLE
   1514           * @see MPU6050_INTERRUPT_MOT_BIT
   1515           **/
   1516          bool MPU6050::getIntMotionEnabled() {
   1517              I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_MOT_BIT, buffer);
   1518              return buffer[0];
   1519          }
   1520          /** Set Motion Detection interrupt enabled status.
   1521           * @param enabled New interrupt enabled status
   1522           * @see getIntMotionEnabled()
   1523           * @see MPU6050_RA_INT_ENABLE
   1524           * @see MPU6050_INTERRUPT_MOT_BIT
   1525           **/
   1526          void MPU6050::setIntMotionEnabled(bool enabled) {
   1527              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_MOT_BIT, enabled);
   1528          }
   1529          /** Get Zero Motion Detection interrupt enabled status.
   1530           * Will be set 0 for disabled, 1 for enabled.
   1531           * @return Current interrupt enabled status
   1532           * @see MPU6050_RA_INT_ENABLE
   1533           * @see MPU6050_INTERRUPT_ZMOT_BIT
   1534           **/
   1535          bool MPU6050::getIntZeroMotionEnabled() {
   1536              I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_ZMOT_BIT, buffer);
   1537              return buffer[0];
   1538          }
   1539          /** Set Zero Motion Detection interrupt enabled status.
   1540           * @param enabled New interrupt enabled status
   1541           * @see getIntZeroMotionEnabled()
   1542           * @see MPU6050_RA_INT_ENABLE
   1543           * @see MPU6050_INTERRUPT_ZMOT_BIT
   1544           **/
   1545          void MPU6050::setIntZeroMotionEnabled(bool enabled) {
   1546              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_ZMOT_BIT, enabled);
   1547          }
   1548          /** Get FIFO Buffer Overflow interrupt enabled status.
   1549           * Will be set 0 for disabled, 1 for enabled.
   1550           * @return Current interrupt enabled status
   1551           * @see MPU6050_RA_INT_ENABLE
   1552           * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT
   1553           **/
   1554          bool MPU6050::getIntFIFOBufferOverflowEnabled() {
   1555              I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, buffer);
   1556              return buffer[0];
   1557          }
   1558          /** Set FIFO Buffer Overflow interrupt enabled status.
   1559           * @param enabled New interrupt enabled status
   1560           * @see getIntFIFOBufferOverflowEnabled()
   1561           * @see MPU6050_RA_INT_ENABLE
   1562           * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT
   1563           **/
   1564          void MPU6050::setIntFIFOBufferOverflowEnabled(bool enabled) {
   1565              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, enabled);
   1566          }
   1567          /** Get I2C Master interrupt enabled status.
   1568           * This enables any of the I2C Master interrupt sources to generate an
   1569           * interrupt. Will be set 0 for disabled, 1 for enabled.
   1570           * @return Current interrupt enabled status
   1571           * @see MPU6050_RA_INT_ENABLE
   1572           * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT
   1573           **/
   1574          bool MPU6050::getIntI2CMasterEnabled() {
   1575              I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_I2C_MST_INT_BIT, buffer);
   1576              return buffer[0];
   1577          }
   1578          /** Set I2C Master interrupt enabled status.
   1579           * @param enabled New interrupt enabled status
   1580           * @see getIntI2CMasterEnabled()
   1581           * @see MPU6050_RA_INT_ENABLE
   1582           * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT
   1583           **/
   1584          void MPU6050::setIntI2CMasterEnabled(bool enabled) {
   1585              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_I2C_MST_INT_BIT, enabled);
   1586          }
   1587          /** Get Data Ready interrupt enabled setting.
   1588           * This event occurs each time a write operation to all of the sensor registers
   1589           * has been completed. Will be set 0 for disabled, 1 for enabled.
   1590           * @return Current interrupt enabled status
   1591           * @see MPU6050_RA_INT_ENABLE
   1592           * @see MPU6050_INTERRUPT_DATA_RDY_BIT
   1593           */
   1594          bool MPU6050::getIntDataReadyEnabled() {
   1595              I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, buffer);
   1596              return buffer[0];
   1597          }
   1598          /** Set Data Ready interrupt enabled status.
   1599           * @param enabled New interrupt enabled status
   1600           * @see getIntDataReadyEnabled()
   1601           * @see MPU6050_RA_INT_CFG
   1602           * @see MPU6050_INTERRUPT_DATA_RDY_BIT
   1603           */
   1604          void MPU6050::setIntDataReadyEnabled(bool enabled) {
   1605              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, enabled);
   1606          }
   1607          
   1608          // INT_STATUS register
   1609          
   1610          /** Get full set of interrupt status bits.
   1611           * These bits clear to 0 after the register has been read. Very useful
   1612           * for getting multiple INT statuses, since each single bit read clears
   1613           * all of them because it has to read the whole byte.
   1614           * @return Current interrupt status
   1615           * @see MPU6050_RA_INT_STATUS
   1616           */
   1617          uint8_t MPU6050::getIntStatus() {
   1618              I2Cdev::readByte(devAddr, MPU6050_RA_INT_STATUS, buffer);
   1619              return buffer[0];
   1620          }
   1621          /** Get Free Fall interrupt status.
   1622           * This bit automatically sets to 1 when a Free Fall interrupt has been
   1623           * generated. The bit clears to 0 after the register has been read.
   1624           * @return Current interrupt status
   1625           * @see MPU6050_RA_INT_STATUS
   1626           * @see MPU6050_INTERRUPT_FF_BIT
   1627           */
   1628          bool MPU6050::getIntFreefallStatus() {
   1629              I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_FF_BIT, buffer);
   1630              return buffer[0];
   1631          }
   1632          /** Get Motion Detection interrupt status.
   1633           * This bit automatically sets to 1 when a Motion Detection interrupt has been
   1634           * generated. The bit clears to 0 after the register has been read.
   1635           * @return Current interrupt status
   1636           * @see MPU6050_RA_INT_STATUS
   1637           * @see MPU6050_INTERRUPT_MOT_BIT
   1638           */
   1639          bool MPU6050::getIntMotionStatus() {
   1640              I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_MOT_BIT, buffer);
   1641              return buffer[0];
   1642          }
   1643          /** Get Zero Motion Detection interrupt status.
   1644           * This bit automatically sets to 1 when a Zero Motion Detection interrupt has
   1645           * been generated. The bit clears to 0 after the register has been read.
   1646           * @return Current interrupt status
   1647           * @see MPU6050_RA_INT_STATUS
   1648           * @see MPU6050_INTERRUPT_ZMOT_BIT
   1649           */
   1650          bool MPU6050::getIntZeroMotionStatus() {
   1651              I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_ZMOT_BIT, buffer);
   1652              return buffer[0];
   1653          }
   1654          /** Get FIFO Buffer Overflow interrupt status.
   1655           * This bit automatically sets to 1 when a Free Fall interrupt has been
   1656           * generated. The bit clears to 0 after the register has been read.
   1657           * @return Current interrupt status
   1658           * @see MPU6050_RA_INT_STATUS
   1659           * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT
   1660           */
   1661          bool MPU6050::getIntFIFOBufferOverflowStatus() {
   1662              I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, buffer);
   1663              return buffer[0];
   1664          }
   1665          /** Get I2C Master interrupt status.
   1666           * This bit automatically sets to 1 when an I2C Master interrupt has been
   1667           * generated. For a list of I2C Master interrupts, please refer to Register 54.
   1668           * The bit clears to 0 after the register has been read.
   1669           * @return Current interrupt status
   1670           * @see MPU6050_RA_INT_STATUS
   1671           * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT
   1672           */
   1673          bool MPU6050::getIntI2CMasterStatus() {
   1674              I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_I2C_MST_INT_BIT, buffer);
   1675              return buffer[0];
   1676          }
   1677          /** Get Data Ready interrupt status.
   1678           * This bit automatically sets to 1 when a Data Ready interrupt has been
   1679           * generated. The bit clears to 0 after the register has been read.
   1680           * @return Current interrupt status
   1681           * @see MPU6050_RA_INT_STATUS
   1682           * @see MPU6050_INTERRUPT_DATA_RDY_BIT
   1683           */
   1684          bool MPU6050::getIntDataReadyStatus() {
   1685              I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_DATA_RDY_BIT, buffer);
   1686              return buffer[0];
   1687          }
   1688          
   1689          // ACCEL_*OUT_* registers
   1690          
   1691          /** Get raw 9-axis motion sensor readings (accel/gyro/compass).
   1692           * FUNCTION NOT FULLY IMPLEMENTED YET.
   1693           * @param ax 16-bit signed integer container for accelerometer X-axis value
   1694           * @param ay 16-bit signed integer container for accelerometer Y-axis value
   1695           * @param az 16-bit signed integer container for accelerometer Z-axis value
   1696           * @param gx 16-bit signed integer container for gyroscope X-axis value
   1697           * @param gy 16-bit signed integer container for gyroscope Y-axis value
   1698           * @param gz 16-bit signed integer container for gyroscope Z-axis value
   1699           * @param mx 16-bit signed integer container for magnetometer X-axis value
   1700           * @param my 16-bit signed integer container for magnetometer Y-axis value
   1701           * @param mz 16-bit signed integer container for magnetometer Z-axis value
   1702           * @see getMotion6()
   1703           * @see getAcceleration()
   1704           * @see getRotation()
   1705           * @see MPU6050_RA_ACCEL_XOUT_H
   1706           */
   1707          void MPU6050::getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz) {
   1708              
   1709          	//get accel and gyro
   1710          	getMotion6(ax, ay, az, gx, gy, gz);
   1711          	
   1712          	//read mag
   1713          	I2Cdev::writeByte(devAddr, MPU6050_RA_INT_PIN_CFG, 0x02); //set i2c bypass enable pin to true to access magnetometer
   1714          	Delay(10);
   1715          	I2Cdev::writeByte(MPU9150_RA_MAG_ADDRESS, 0x0A, 0x01); //enable the magnetometer
   1716          	Delay(10);
   1717          	I2Cdev::readBytes(MPU9150_RA_MAG_ADDRESS, MPU9150_RA_MAG_XOUT_L, 6, buffer);
   1718          	*mx = (((int16_t)buffer[1]) << 8) | buffer[0];
   1719              *my = (((int16_t)buffer[3]) << 8) | buffer[2];
   1720              *mz = (((int16_t)buffer[5]) << 8) | buffer[4];		
   1721          }
   1722          /** Get raw 6-axis motion sensor readings (accel/gyro).
   1723           * Retrieves all currently available motion sensor values.
   1724           * @param ax 16-bit signed integer container for accelerometer X-axis value
   1725           * @param ay 16-bit signed integer container for accelerometer Y-axis value
   1726           * @param az 16-bit signed integer container for accelerometer Z-axis value
   1727           * @param gx 16-bit signed integer container for gyroscope X-axis value
   1728           * @param gy 16-bit signed integer container for gyroscope Y-axis value
   1729           * @param gz 16-bit signed integer container for gyroscope Z-axis value
   1730           * @see getAcceleration()
   1731           * @see getRotation()
   1732           * @see MPU6050_RA_ACCEL_XOUT_H
   1733           */
   1734          void MPU6050::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
   1735              I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 14, buffer);
   1736              *ax = (((int16_t)buffer[0]) << 8) | buffer[1];
   1737              *ay = (((int16_t)buffer[2]) << 8) | buffer[3];
   1738              *az = (((int16_t)buffer[4]) << 8) | buffer[5];
   1739              *gx = (((int16_t)buffer[8]) << 8) | buffer[9];
   1740              *gy = (((int16_t)buffer[10]) << 8) | buffer[11];
   1741              *gz = (((int16_t)buffer[12]) << 8) | buffer[13];
   1742          }
   1743          /** Get 3-axis accelerometer readings.
   1744           * These registers store the most recent accelerometer measurements.
   1745           * Accelerometer measurements are written to these registers at the Sample Rate
   1746           * as defined in Register 25.
   1747           *
   1748           * The accelerometer measurement registers, along with the temperature
   1749           * measurement registers, gyroscope measurement registers, and external sensor
   1750           * data registers, are composed of two sets of registers: an internal register
   1751           * set and a user-facing read register set.
   1752           *
   1753           * The data within the accelerometer sensors' internal register set is always
   1754           * updated at the Sample Rate. Meanwhile, the user-facing read register set
   1755           * duplicates the internal register set's data values whenever the serial
   1756           * interface is idle. This guarantees that a burst read of sensor registers will
   1757           * read measurements from the same sampling instant. Note that if burst reads
   1758           * are not used, the user is responsible for ensuring a set of single byte reads
   1759           * correspond to a single sampling instant by checking the Data Ready interrupt.
   1760           *
   1761           * Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS
   1762           * (Register 28). For each full scale setting, the accelerometers' sensitivity
   1763           * per LSB in ACCEL_xOUT is shown in the table below:
   1764           *
   1765           * <pre>
   1766           * AFS_SEL | Full Scale Range | LSB Sensitivity
   1767           * --------+------------------+----------------
   1768           * 0       | +/- 2g           | 8192 LSB/mg
   1769           * 1       | +/- 4g           | 4096 LSB/mg
   1770           * 2       | +/- 8g           | 2048 LSB/mg
   1771           * 3       | +/- 16g          | 1024 LSB/mg
   1772           * </pre>
   1773           *
   1774           * @param x 16-bit signed integer container for X-axis acceleration
   1775           * @param y 16-bit signed integer container for Y-axis acceleration
   1776           * @param z 16-bit signed integer container for Z-axis acceleration
   1777           * @see MPU6050_RA_GYRO_XOUT_H
   1778           */
   1779          void MPU6050::getAcceleration(int16_t* x, int16_t* y, int16_t* z) {
   1780              I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 6, buffer);
   1781              *x = (((int16_t)buffer[0]) << 8) | buffer[1];
   1782              *y = (((int16_t)buffer[2]) << 8) | buffer[3];
   1783              *z = (((int16_t)buffer[4]) << 8) | buffer[5];
   1784          }
   1785          /** Get X-axis accelerometer reading.
   1786           * @return X-axis acceleration measurement in 16-bit 2's complement format
   1787           * @see getMotion6()
   1788           * @see MPU6050_RA_ACCEL_XOUT_H
   1789           */
   1790          int16_t MPU6050::getAccelerationX() {
   1791              I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 2, buffer);
   1792              return (((int16_t)buffer[0]) << 8) | buffer[1];
   1793          }
   1794          /** Get Y-axis accelerometer reading.
   1795           * @return Y-axis acceleration measurement in 16-bit 2's complement format
   1796           * @see getMotion6()
   1797           * @see MPU6050_RA_ACCEL_YOUT_H
   1798           */
   1799          int16_t MPU6050::getAccelerationY() {
   1800              I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_YOUT_H, 2, buffer);
   1801              return (((int16_t)buffer[0]) << 8) | buffer[1];
   1802          }
   1803          /** Get Z-axis accelerometer reading.
   1804           * @return Z-axis acceleration measurement in 16-bit 2's complement format
   1805           * @see getMotion6()
   1806           * @see MPU6050_RA_ACCEL_ZOUT_H
   1807           */
   1808          int16_t MPU6050::getAccelerationZ() {
   1809              I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_ZOUT_H, 2, buffer);
   1810              return (((int16_t)buffer[0]) << 8) | buffer[1];
   1811          }
   1812          
   1813          // TEMP_OUT_* registers
   1814          
   1815          /** Get current internal temperature.
   1816           * @return Temperature reading in 16-bit 2's complement format
   1817           * @see MPU6050_RA_TEMP_OUT_H
   1818           */
   1819          int16_t MPU6050::getTemperature() {
   1820              I2Cdev::readBytes(devAddr, MPU6050_RA_TEMP_OUT_H, 2, buffer);
   1821              return (((int16_t)buffer[0]) << 8) | buffer[1];
   1822          }
   1823          
   1824          // GYRO_*OUT_* registers
   1825          
   1826          /** Get 3-axis gyroscope readings.
   1827           * These gyroscope measurement registers, along with the accelerometer
   1828           * measurement registers, temperature measurement registers, and external sensor
   1829           * data registers, are composed of two sets of registers: an internal register
   1830           * set and a user-facing read register set.
   1831           * The data within the gyroscope sensors' internal register set is always
   1832           * updated at the Sample Rate. Meanwhile, the user-facing read register set
   1833           * duplicates the internal register set's data values whenever the serial
   1834           * interface is idle. This guarantees that a burst read of sensor registers will
   1835           * read measurements from the same sampling instant. Note that if burst reads
   1836           * are not used, the user is responsible for ensuring a set of single byte reads
   1837           * correspond to a single sampling instant by checking the Data Ready interrupt.
   1838           *
   1839           * Each 16-bit gyroscope measurement has a full scale defined in FS_SEL
   1840           * (Register 27). For each full scale setting, the gyroscopes' sensitivity per
   1841           * LSB in GYRO_xOUT is shown in the table below:
   1842           *
   1843           * <pre>
   1844           * FS_SEL | Full Scale Range   | LSB Sensitivity
   1845           * -------+--------------------+----------------
   1846           * 0      | +/- 250 degrees/s  | 131 LSB/deg/s
   1847           * 1      | +/- 500 degrees/s  | 65.5 LSB/deg/s
   1848           * 2      | +/- 1000 degrees/s | 32.8 LSB/deg/s
   1849           * 3      | +/- 2000 degrees/s | 16.4 LSB/deg/s
   1850           * </pre>
   1851           *
   1852           * @param x 16-bit signed integer container for X-axis rotation
   1853           * @param y 16-bit signed integer container for Y-axis rotation
   1854           * @param z 16-bit signed integer container for Z-axis rotation
   1855           * @see getMotion6()
   1856           * @see MPU6050_RA_GYRO_XOUT_H
   1857           */
   1858          void MPU6050::getRotation(int16_t* x, int16_t* y, int16_t* z) {
   1859              I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_XOUT_H, 6, buffer);
   1860              *x = (((int16_t)buffer[0]) << 8) | buffer[1];
   1861              *y = (((int16_t)buffer[2]) << 8) | buffer[3];
   1862              *z = (((int16_t)buffer[4]) << 8) | buffer[5];
   1863          }
   1864          /** Get X-axis gyroscope reading.
   1865           * @return X-axis rotation measurement in 16-bit 2's complement format
   1866           * @see getMotion6()
   1867           * @see MPU6050_RA_GYRO_XOUT_H
   1868           */
   1869          int16_t MPU6050::getRotationX() {
   1870              I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_XOUT_H, 2, buffer);
   1871              return (((int16_t)buffer[0]) << 8) | buffer[1];
   1872          }
   1873          /** Get Y-axis gyroscope reading.
   1874           * @return Y-axis rotation measurement in 16-bit 2's complement format
   1875           * @see getMotion6()
   1876           * @see MPU6050_RA_GYRO_YOUT_H
   1877           */
   1878          int16_t MPU6050::getRotationY() {
   1879              I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_YOUT_H, 2, buffer);
   1880              return (((int16_t)buffer[0]) << 8) | buffer[1];
   1881          }
   1882          /** Get Z-axis gyroscope reading.
   1883           * @return Z-axis rotation measurement in 16-bit 2's complement format
   1884           * @see getMotion6()
   1885           * @see MPU6050_RA_GYRO_ZOUT_H
   1886           */
   1887          int16_t MPU6050::getRotationZ() {
   1888              I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_ZOUT_H, 2, buffer);
   1889              return (((int16_t)buffer[0]) << 8) | buffer[1];
   1890          }
   1891          
   1892          // EXT_SENS_DATA_* registers
   1893          
   1894          /** Read single byte from external sensor data register.
   1895           * These registers store data read from external sensors by the Slave 0, 1, 2,
   1896           * and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in
   1897           * I2C_SLV4_DI (Register 53).
   1898           *
   1899           * External sensor data is written to these registers at the Sample Rate as
   1900           * defined in Register 25. This access rate can be reduced by using the Slave
   1901           * Delay Enable registers (Register 103).
   1902           *
   1903           * External sensor data registers, along with the gyroscope measurement
   1904           * registers, accelerometer measurement registers, and temperature measurement
   1905           * registers, are composed of two sets of registers: an internal register set
   1906           * and a user-facing read register set.
   1907           *
   1908           * The data within the external sensors' internal register set is always updated
   1909           * at the Sample Rate (or the reduced access rate) whenever the serial interface
   1910           * is idle. This guarantees that a burst read of sensor registers will read
   1911           * measurements from the same sampling instant. Note that if burst reads are not
   1912           * used, the user is responsible for ensuring a set of single byte reads
   1913           * correspond to a single sampling instant by checking the Data Ready interrupt.
   1914           *
   1915           * Data is placed in these external sensor data registers according to
   1916           * I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39,
   1917           * 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN > 0) from
   1918           * an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as
   1919           * defined in Register 25) or delayed rate (if specified in Register 52 and
   1920           * 103). During each Sample cycle, slave reads are performed in order of Slave
   1921           * number. If all slaves are enabled with more than zero bytes to be read, the
   1922           * order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.
   1923           *
   1924           * Each enabled slave will have EXT_SENS_DATA registers associated with it by
   1925           * number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from
   1926           * EXT_SENS_DATA_00. Note that this means enabling or disabling a slave may
   1927           * change the higher numbered slaves' associated registers. Furthermore, if
   1928           * fewer total bytes are being read from the external sensors as a result of
   1929           * such a change, then the data remaining in the registers which no longer have
   1930           * an associated slave device (i.e. high numbered registers) will remain in
   1931           * these previously allocated registers unless reset.
   1932           *
   1933           * If the sum of the read lengths of all SLVx transactions exceed the number of
   1934           * available EXT_SENS_DATA registers, the excess bytes will be dropped. There
   1935           * are 24 EXT_SENS_DATA registers and hence the total read lengths between all
   1936           * the slaves cannot be greater than 24 or some bytes will be lost.
   1937           *
   1938           * Note: Slave 4's behavior is distinct from that of Slaves 0-3. For further
   1939           * information regarding the characteristics of Slave 4, please refer to
   1940           * Registers 49 to 53.
   1941           *
   1942           * EXAMPLE:
   1943           * Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and
   1944           * I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read so that
   1945           * I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation, EXT_SENS_DATA _00
   1946           * through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05
   1947           * will be associated with Slave 1. If Slave 2 is enabled as well, registers
   1948           * starting from EXT_SENS_DATA_06 will be allocated to Slave 2.
   1949           *
   1950           * If Slave 2 is disabled while Slave 3 is enabled in this same situation, then
   1951           * registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3
   1952           * instead.
   1953           *
   1954           * REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE:
   1955           * If a slave is disabled at any time, the space initially allocated to the
   1956           * slave in the EXT_SENS_DATA register, will remain associated with that slave.
   1957           * This is to avoid dynamic adjustment of the register allocation.
   1958           *
   1959           * The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all
   1960           * slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106).
   1961           *
   1962           * This above is also true if one of the slaves gets NACKed and stops
   1963           * functioning.
   1964           *
   1965           * @param position Starting position (0-23)
   1966           * @return Byte read from register
   1967           */
   1968          uint8_t MPU6050::getExternalSensorByte(int position) {
   1969              I2Cdev::readByte(devAddr, MPU6050_RA_EXT_SENS_DATA_00 + position, buffer);
   1970              return buffer[0];
   1971          }
   1972          /** Read word (2 bytes) from external sensor data registers.
   1973           * @param position Starting position (0-21)
   1974           * @return Word read from register
   1975           * @see getExternalSensorByte()
   1976           */
   1977          uint16_t MPU6050::getExternalSensorWord(int position) {
   1978              I2Cdev::readBytes(devAddr, MPU6050_RA_EXT_SENS_DATA_00 + position, 2, buffer);
   1979              return (((uint16_t)buffer[0]) << 8) | buffer[1];
   1980          }
   1981          /** Read double word (4 bytes) from external sensor data registers.
   1982           * @param position Starting position (0-20)
   1983           * @return Double word read from registers
   1984           * @see getExternalSensorByte()
   1985           */
   1986          uint32_t MPU6050::getExternalSensorDWord(int position) {
   1987              I2Cdev::readBytes(devAddr, MPU6050_RA_EXT_SENS_DATA_00 + position, 4, buffer);
   1988              return (((uint32_t)buffer[0]) << 24) | (((uint32_t)buffer[1]) << 16) | (((uint16_t)buffer[2]) << 8) | buffer[3];
   1989          }
   1990          
   1991          // MOT_DETECT_STATUS register
   1992          
   1993          /** Get X-axis negative motion detection interrupt status.
   1994           * @return Motion detection status
   1995           * @see MPU6050_RA_MOT_DETECT_STATUS
   1996           * @see MPU6050_MOTION_MOT_XNEG_BIT
   1997           */
   1998          bool MPU6050::getXNegMotionDetected() {
   1999              I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_XNEG_BIT, buffer);
   2000              return buffer[0];
   2001          }
   2002          /** Get X-axis positive motion detection interrupt status.
   2003           * @return Motion detection status
   2004           * @see MPU6050_RA_MOT_DETECT_STATUS
   2005           * @see MPU6050_MOTION_MOT_XPOS_BIT
   2006           */
   2007          bool MPU6050::getXPosMotionDetected() {
   2008              I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_XPOS_BIT, buffer);
   2009              return buffer[0];
   2010          }
   2011          /** Get Y-axis negative motion detection interrupt status.
   2012           * @return Motion detection status
   2013           * @see MPU6050_RA_MOT_DETECT_STATUS
   2014           * @see MPU6050_MOTION_MOT_YNEG_BIT
   2015           */
   2016          bool MPU6050::getYNegMotionDetected() {
   2017              I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_YNEG_BIT, buffer);
   2018              return buffer[0];
   2019          }
   2020          /** Get Y-axis positive motion detection interrupt status.
   2021           * @return Motion detection status
   2022           * @see MPU6050_RA_MOT_DETECT_STATUS
   2023           * @see MPU6050_MOTION_MOT_YPOS_BIT
   2024           */
   2025          bool MPU6050::getYPosMotionDetected() {
   2026              I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_YPOS_BIT, buffer);
   2027              return buffer[0];
   2028          }
   2029          /** Get Z-axis negative motion detection interrupt status.
   2030           * @return Motion detection status
   2031           * @see MPU6050_RA_MOT_DETECT_STATUS
   2032           * @see MPU6050_MOTION_MOT_ZNEG_BIT
   2033           */
   2034          bool MPU6050::getZNegMotionDetected() {
   2035              I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_ZNEG_BIT, buffer);
   2036              return buffer[0];
   2037          }
   2038          /** Get Z-axis positive motion detection interrupt status.
   2039           * @return Motion detection status
   2040           * @see MPU6050_RA_MOT_DETECT_STATUS
   2041           * @see MPU6050_MOTION_MOT_ZPOS_BIT
   2042           */
   2043          bool MPU6050::getZPosMotionDetected() {
   2044              I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_ZPOS_BIT, buffer);
   2045              return buffer[0];
   2046          }
   2047          /** Get zero motion detection interrupt status.
   2048           * @return Motion detection status
   2049           * @see MPU6050_RA_MOT_DETECT_STATUS
   2050           * @see MPU6050_MOTION_MOT_ZRMOT_BIT
   2051           */
   2052          bool MPU6050::getZeroMotionDetected() {
   2053              I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_ZRMOT_BIT, buffer);
   2054              return buffer[0];
   2055          }
   2056          
   2057          // I2C_SLV*_DO register
   2058          
   2059          /** Write byte to Data Output container for specified slave.
   2060           * This register holds the output data written into Slave when Slave is set to
   2061           * write mode. For further information regarding Slave control, please
   2062           * refer to Registers 37 to 39 and immediately following.
   2063           * @param num Slave number (0-3)
   2064           * @param data Byte to write
   2065           * @see MPU6050_RA_I2C_SLV0_DO
   2066           */
   2067          void MPU6050::setSlaveOutputByte(uint8_t num, uint8_t data) {
   2068              if (num > 3) return;
   2069              I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_DO + num, data);
   2070          }
   2071          
   2072          // I2C_MST_DELAY_CTRL register
   2073          
   2074          /** Get external data shadow delay enabled status.
   2075           * This register is used to specify the timing of external sensor data
   2076           * shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of external
   2077           * sensor data is delayed until all data has been received.
   2078           * @return Current external data shadow delay enabled status.
   2079           * @see MPU6050_RA_I2C_MST_DELAY_CTRL
   2080           * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT
   2081           */
   2082          bool MPU6050::getExternalShadowDelayEnabled() {
   2083              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT, buffer);
   2084              return buffer[0];
   2085          }
   2086          /** Set external data shadow delay enabled status.
   2087           * @param enabled New external data shadow delay enabled status.
   2088           * @see getExternalShadowDelayEnabled()
   2089           * @see MPU6050_RA_I2C_MST_DELAY_CTRL
   2090           * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT
   2091           */
   2092          void MPU6050::setExternalShadowDelayEnabled(bool enabled) {
   2093              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT, enabled);
   2094          }
   2095          /** Get slave delay enabled status.
   2096           * When a particular slave delay is enabled, the rate of access for the that
   2097           * slave device is reduced. When a slave's access rate is decreased relative to
   2098           * the Sample Rate, the slave is accessed every:
   2099           *
   2100           *     1 / (1 + I2C_MST_DLY) Samples
   2101           *
   2102           * This base Sample Rate in turn is determined by SMPLRT_DIV (register  * 25)
   2103           * and DLPF_CFG (register 26).
   2104           *
   2105           * For further information regarding I2C_MST_DLY, please refer to register 52.
   2106           * For further information regarding the Sample Rate, please refer to register 25.
   2107           *
   2108           * @param num Slave number (0-4)
   2109           * @return Current slave delay enabled status.
   2110           * @see MPU6050_RA_I2C_MST_DELAY_CTRL
   2111           * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT
   2112           */
   2113          bool MPU6050::getSlaveDelayEnabled(uint8_t num) {
   2114              // MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT is 4, SLV3 is 3, etc.
   2115              if (num > 4) return 0;
   2116              I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, num, buffer);
   2117              return buffer[0];
   2118          }
   2119          /** Set slave delay enabled status.
   2120           * @param num Slave number (0-4)
   2121           * @param enabled New slave delay enabled status.
   2122           * @see MPU6050_RA_I2C_MST_DELAY_CTRL
   2123           * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT
   2124           */
   2125          void MPU6050::setSlaveDelayEnabled(uint8_t num, bool enabled) {
   2126              I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, num, enabled);
   2127          }
   2128          
   2129          // SIGNAL_PATH_RESET register
   2130          
   2131          /** Reset gyroscope signal path.
   2132           * The reset will revert the signal path analog to digital converters and
   2133           * filters to their power up configurations.
   2134           * @see MPU6050_RA_SIGNAL_PATH_RESET
   2135           * @see MPU6050_PATHRESET_GYRO_RESET_BIT
   2136           */
   2137          void MPU6050::resetGyroscopePath() {
   2138              I2Cdev::writeBit(devAddr, MPU6050_RA_SIGNAL_PATH_RESET, MPU6050_PATHRESET_GYRO_RESET_BIT, true);
   2139          }
   2140          /** Reset accelerometer signal path.
   2141           * The reset will revert the signal path analog to digital converters and
   2142           * filters to their power up configurations.
   2143           * @see MPU6050_RA_SIGNAL_PATH_RESET
   2144           * @see MPU6050_PATHRESET_ACCEL_RESET_BIT
   2145           */
   2146          void MPU6050::resetAccelerometerPath() {
   2147              I2Cdev::writeBit(devAddr, MPU6050_RA_SIGNAL_PATH_RESET, MPU6050_PATHRESET_ACCEL_RESET_BIT, true);
   2148          }
   2149          /** Reset temperature sensor signal path.
   2150           * The reset will revert the signal path analog to digital converters and
   2151           * filters to their power up configurations.
   2152           * @see MPU6050_RA_SIGNAL_PATH_RESET
   2153           * @see MPU6050_PATHRESET_TEMP_RESET_BIT
   2154           */
   2155          void MPU6050::resetTemperaturePath() {
   2156              I2Cdev::writeBit(devAddr, MPU6050_RA_SIGNAL_PATH_RESET, MPU6050_PATHRESET_TEMP_RESET_BIT, true);
   2157          }
   2158          
   2159          // MOT_DETECT_CTRL register
   2160          
   2161          /** Get accelerometer power-on delay.
   2162           * The accelerometer data path provides samples to the sensor registers, Motion
   2163           * detection, Zero Motion detection, and Free Fall detection modules. The
   2164           * signal path contains filters which must be flushed on wake-up with new
   2165           * samples before the detection modules begin operations. The default wake-up
   2166           * delay, of 4ms can be lengthened by up to 3ms. This additional delay is
   2167           * specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select
   2168           * any value above zero unless instructed otherwise by InvenSense. Please refer
   2169           * to Section 8 of the MPU-6000/MPU-6050 Product Specification document for
   2170           * further information regarding the detection modules.
   2171           * @return Current accelerometer power-on delay
   2172           * @see MPU6050_RA_MOT_DETECT_CTRL
   2173           * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT
   2174           */
   2175          uint8_t MPU6050::getAccelerometerPowerOnDelay() {
   2176              I2Cdev::readBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_ACCEL_ON_DELAY_BIT, MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH, buffer);
   2177              return buffer[0];
   2178          }
   2179          /** Set accelerometer power-on delay.
   2180           * @param delay New accelerometer power-on delay (0-3)
   2181           * @see getAccelerometerPowerOnDelay()
   2182           * @see MPU6050_RA_MOT_DETECT_CTRL
   2183           * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT
   2184           */
   2185          void MPU6050::setAccelerometerPowerOnDelay(uint8_t delay) {
   2186              I2Cdev::writeBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_ACCEL_ON_DELAY_BIT, MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH, delay);
   2187          }
   2188          /** Get Free Fall detection counter decrement configuration.
   2189           * Detection is registered by the Free Fall detection module after accelerometer
   2190           * measurements meet their respective threshold conditions over a specified
   2191           * number of samples. When the threshold conditions are met, the corresponding
   2192           * detection counter increments by 1. The user may control the rate at which the
   2193           * detection counter decrements when the threshold condition is not met by
   2194           * configuring FF_COUNT. The decrement rate can be set according to the
   2195           * following table:
   2196           *
   2197           * <pre>
   2198           * FF_COUNT | Counter Decrement
   2199           * ---------+------------------
   2200           * 0        | Reset
   2201           * 1        | 1
   2202           * 2        | 2
   2203           * 3        | 4
   2204           * </pre>
   2205           *
   2206           * When FF_COUNT is configured to 0 (reset), any non-qualifying sample will
   2207           * reset the counter to 0. For further information on Free Fall detection,
   2208           * please refer to Registers 29 to 32.
   2209           *
   2210           * @return Current decrement configuration
   2211           * @see MPU6050_RA_MOT_DETECT_CTRL
   2212           * @see MPU6050_DETECT_FF_COUNT_BIT
   2213           */
   2214          uint8_t MPU6050::getFreefallDetectionCounterDecrement() {
   2215              I2Cdev::readBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_FF_COUNT_BIT, MPU6050_DETECT_FF_COUNT_LENGTH, buffer);
   2216              return buffer[0];
   2217          }
   2218          /** Set Free Fall detection counter decrement configuration.
   2219           * @param decrement New decrement configuration value
   2220           * @see getFreefallDetectionCounterDecrement()
   2221           * @see MPU6050_RA_MOT_DETECT_CTRL
   2222           * @see MPU6050_DETECT_FF_COUNT_BIT
   2223           */
   2224          void MPU6050::setFreefallDetectionCounterDecrement(uint8_t decrement) {
   2225              I2Cdev::writeBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_FF_COUNT_BIT, MPU6050_DETECT_FF_COUNT_LENGTH, decrement);
   2226          }
   2227          /** Get Motion detection counter decrement configuration.
   2228           * Detection is registered by the Motion detection module after accelerometer
   2229           * measurements meet their respective threshold conditions over a specified
   2230           * number of samples. When the threshold conditions are met, the corresponding
   2231           * detection counter increments by 1. The user may control the rate at which the
   2232           * detection counter decrements when the threshold condition is not met by
   2233           * configuring MOT_COUNT. The decrement rate can be set according to the
   2234           * following table:
   2235           *
   2236           * <pre>
   2237           * MOT_COUNT | Counter Decrement
   2238           * ----------+------------------
   2239           * 0         | Reset
   2240           * 1         | 1
   2241           * 2         | 2
   2242           * 3         | 4
   2243           * </pre>
   2244           *
   2245           * When MOT_COUNT is configured to 0 (reset), any non-qualifying sample will
   2246           * reset the counter to 0. For further information on Motion detection,
   2247           * please refer to Registers 29 to 32.
   2248           *
   2249           */
   2250          uint8_t MPU6050::getMotionDetectionCounterDecrement() {
   2251              I2Cdev::readBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_MOT_COUNT_BIT, MPU6050_DETECT_MOT_COUNT_LENGTH, buffer);
   2252              return buffer[0];
   2253          }
   2254          /** Set Motion detection counter decrement configuration.
   2255           * @param decrement New decrement configuration value
   2256           * @see getMotionDetectionCounterDecrement()
   2257           * @see MPU6050_RA_MOT_DETECT_CTRL
   2258           * @see MPU6050_DETECT_MOT_COUNT_BIT
   2259           */
   2260          void MPU6050::setMotionDetectionCounterDecrement(uint8_t decrement) {
   2261              I2Cdev::writeBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_MOT_COUNT_BIT, MPU6050_DETECT_MOT_COUNT_LENGTH, decrement);
   2262          }
   2263          
   2264          // USER_CTRL register
   2265          
   2266          /** Get FIFO enabled status.
   2267           * When this bit is set to 0, the FIFO buffer is disabled. The FIFO buffer
   2268           * cannot be written to or read from while disabled. The FIFO buffer's state
   2269           * does not change unless the MPU-60X0 is power cycled.
   2270           * @return Current FIFO enabled status
   2271           * @see MPU6050_RA_USER_CTRL
   2272           * @see MPU6050_USERCTRL_FIFO_EN_BIT
   2273           */
   2274          bool MPU6050::getFIFOEnabled() {
   2275              I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, buffer);
   2276              return buffer[0];
   2277          }
   2278          /** Set FIFO enabled status.
   2279           * @param enabled New FIFO enabled status
   2280           * @see getFIFOEnabled()
   2281           * @see MPU6050_RA_USER_CTRL
   2282           * @see MPU6050_USERCTRL_FIFO_EN_BIT
   2283           */
   2284          void MPU6050::setFIFOEnabled(bool enabled) {
   2285              I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, enabled);
   2286          }
   2287          /** Get I2C Master Mode enabled status.
   2288           * When this mode is enabled, the MPU-60X0 acts as the I2C Master to the
   2289           * external sensor slave devices on the auxiliary I2C bus. When this bit is
   2290           * cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically
   2291           * driven by the primary I2C bus (SDA and SCL). This is a precondition to
   2292           * enabling Bypass Mode. For further information regarding Bypass Mode, please
   2293           * refer to Register 55.
   2294           * @return Current I2C Master Mode enabled status
   2295           * @see MPU6050_RA_USER_CTRL
   2296           * @see MPU6050_USERCTRL_I2C_MST_EN_BIT
   2297           */
   2298          bool MPU6050::getI2CMasterModeEnabled() {
   2299              I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, buffer);
   2300              return buffer[0];
   2301          }
   2302          /** Set I2C Master Mode enabled status.
   2303           * @param enabled New I2C Master Mode enabled status
   2304           * @see getI2CMasterModeEnabled()
   2305           * @see MPU6050_RA_USER_CTRL
   2306           * @see MPU6050_USERCTRL_I2C_MST_EN_BIT
   2307           */
   2308          void MPU6050::setI2CMasterModeEnabled(bool enabled) {
   2309              I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, enabled);
   2310          }
   2311          /** Switch from I2C to SPI mode (MPU-6000 only)
   2312           * If this is set, the primary SPI interface will be enabled in place of the
   2313           * disabled primary I2C interface.
   2314           */
   2315          void MPU6050::switchSPIEnabled(bool enabled) {
   2316              I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_IF_DIS_BIT, enabled);
   2317          }
   2318          /** Reset the FIFO.
   2319           * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This
   2320           * bit automatically clears to 0 after the reset has been triggered.
   2321           * @see MPU6050_RA_USER_CTRL
   2322           * @see MPU6050_USERCTRL_FIFO_RESET_BIT
   2323           */
   2324          void MPU6050::resetFIFO() {
   2325              I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, true);
   2326          }
   2327          /** Reset the I2C Master.
   2328           * This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0.
   2329           * This bit automatically clears to 0 after the reset has been triggered.
   2330           * @see MPU6050_RA_USER_CTRL
   2331           * @see MPU6050_USERCTRL_I2C_MST_RESET_BIT
   2332           */
   2333          void MPU6050::resetI2CMaster() {
   2334              I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_RESET_BIT, true);
   2335          }
   2336          /** Reset all sensor registers and signal paths.
   2337           * When set to 1, this bit resets the signal paths for all sensors (gyroscopes,
   2338           * accelerometers, and temperature sensor). This operation will also clear the
   2339           * sensor registers. This bit automatically clears to 0 after the reset has been
   2340           * triggered.
   2341           *
   2342           * When resetting only the signal path (and not the sensor registers), please
   2343           * use Register 104, SIGNAL_PATH_RESET.
   2344           *
   2345           * @see MPU6050_RA_USER_CTRL
   2346           * @see MPU6050_USERCTRL_SIG_COND_RESET_BIT
   2347           */
   2348          void MPU6050::resetSensors() {
   2349              I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_SIG_COND_RESET_BIT, true);
   2350          }
   2351          
   2352          // PWR_MGMT_1 register
   2353          
   2354          /** Trigger a full device reset.
   2355           * A small delay of ~50ms may be desirable after triggering a reset.
   2356           * @see MPU6050_RA_PWR_MGMT_1
   2357           * @see MPU6050_PWR1_DEVICE_RESET_BIT
   2358           */
   2359          void MPU6050::reset() {
   2360              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, true);
   2361          }
   2362          /** Get sleep mode status.
   2363           * Setting the SLEEP bit in the register puts the device into very low power
   2364           * sleep mode. In this mode, only the serial interface and internal registers
   2365           * remain active, allowing for a very low standby current. Clearing this bit
   2366           * puts the device back into normal mode. To save power, the individual standby
   2367           * selections for each of the gyros should be used if any gyro axis is not used
   2368           * by the application.
   2369           * @return Current sleep mode enabled status
   2370           * @see MPU6050_RA_PWR_MGMT_1
   2371           * @see MPU6050_PWR1_SLEEP_BIT
   2372           */
   2373          bool MPU6050::getSleepEnabled() {
   2374              I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, buffer);
   2375              return buffer[0];
   2376          }
   2377          /** Set sleep mode status.
   2378           * @param enabled New sleep mode enabled status
   2379           * @see getSleepEnabled()
   2380           * @see MPU6050_RA_PWR_MGMT_1
   2381           * @see MPU6050_PWR1_SLEEP_BIT
   2382           */
   2383          void MPU6050::setSleepEnabled(bool enabled) {
   2384              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, enabled);
   2385          }
   2386          /** Get wake cycle enabled status.
   2387           * When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle
   2388           * between sleep mode and waking up to take a single sample of data from active
   2389           * sensors at a rate determined by LP_WAKE_CTRL (register 108).
   2390           * @return Current sleep mode enabled status
   2391           * @see MPU6050_RA_PWR_MGMT_1
   2392           * @see MPU6050_PWR1_CYCLE_BIT
   2393           */
   2394          bool MPU6050::getWakeCycleEnabled() {
   2395              I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CYCLE_BIT, buffer);
   2396              return buffer[0];
   2397          }
   2398          /** Set wake cycle enabled status.
   2399           * @param enabled New sleep mode enabled status
   2400           * @see getWakeCycleEnabled()
   2401           * @see MPU6050_RA_PWR_MGMT_1
   2402           * @see MPU6050_PWR1_CYCLE_BIT
   2403           */
   2404          void MPU6050::setWakeCycleEnabled(bool enabled) {
   2405              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CYCLE_BIT, enabled);
   2406          }
   2407          /** Get temperature sensor enabled status.
   2408           * Control the usage of the internal temperature sensor.
   2409           *
   2410           * Note: this register stores the *disabled* value, but for consistency with the
   2411           * rest of the code, the function is named and used with standard true/false
   2412           * values to indicate whether the sensor is enabled or disabled, respectively.
   2413           *
   2414           * @return Current temperature sensor enabled status
   2415           * @see MPU6050_RA_PWR_MGMT_1
   2416           * @see MPU6050_PWR1_TEMP_DIS_BIT
   2417           */
   2418          bool MPU6050::getTempSensorEnabled() {
   2419              I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, buffer);
   2420              return buffer[0] == 0; // 1 is actually disabled here
   2421          }
   2422          /** Set temperature sensor enabled status.
   2423           * Note: this register stores the *disabled* value, but for consistency with the
   2424           * rest of the code, the function is named and used with standard true/false
   2425           * values to indicate whether the sensor is enabled or disabled, respectively.
   2426           *
   2427           * @param enabled New temperature sensor enabled status
   2428           * @see getTempSensorEnabled()
   2429           * @see MPU6050_RA_PWR_MGMT_1
   2430           * @see MPU6050_PWR1_TEMP_DIS_BIT
   2431           */
   2432          void MPU6050::setTempSensorEnabled(bool enabled) {
   2433              // 1 is actually disabled here
   2434              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, !enabled);
   2435          }
   2436          /** Get clock source setting.
   2437           * @return Current clock source setting
   2438           * @see MPU6050_RA_PWR_MGMT_1
   2439           * @see MPU6050_PWR1_CLKSEL_BIT
   2440           * @see MPU6050_PWR1_CLKSEL_LENGTH
   2441           */
   2442          uint8_t MPU6050::getClockSource() {
   2443              I2Cdev::readBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, buffer);
   2444              return buffer[0];
   2445          }
   2446          /** Set clock source setting.
   2447           * An internal 8MHz oscillator, gyroscope based clock, or external sources can
   2448           * be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator
   2449           * or an external source is chosen as the clock source, the MPU-60X0 can operate
   2450           * in low power modes with the gyroscopes disabled.
   2451           *
   2452           * Upon power up, the MPU-60X0 clock source defaults to the internal oscillator.
   2453           * However, it is highly recommended that the device be configured to use one of
   2454           * the gyroscopes (or an external clock source) as the clock reference for
   2455           * improved stability. The clock source can be selected according to the following table:
   2456           *
   2457           * <pre>
   2458           * CLK_SEL | Clock Source
   2459           * --------+--------------------------------------
   2460           * 0       | Internal oscillator
   2461           * 1       | PLL with X Gyro reference
   2462           * 2       | PLL with Y Gyro reference
   2463           * 3       | PLL with Z Gyro reference
   2464           * 4       | PLL with external 32.768kHz reference
   2465           * 5       | PLL with external 19.2MHz reference
   2466           * 6       | Reserved
   2467           * 7       | Stops the clock and keeps the timing generator in reset
   2468           * </pre>
   2469           *
   2470           * @param source New clock source setting
   2471           * @see getClockSource()
   2472           * @see MPU6050_RA_PWR_MGMT_1
   2473           * @see MPU6050_PWR1_CLKSEL_BIT
   2474           * @see MPU6050_PWR1_CLKSEL_LENGTH
   2475           */
   2476          void MPU6050::setClockSource(uint8_t source) {
   2477              I2Cdev::writeBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);
   2478          }
   2479          
   2480          // PWR_MGMT_2 register
   2481          
   2482          /** Get wake frequency in Accel-Only Low Power Mode.
   2483           * The MPU-60X0 can be put into Accerlerometer Only Low Power Mode by setting
   2484           * PWRSEL to 1 in the Power Management 1 register (Register 107). In this mode,
   2485           * the device will power off all devices except for the primary I2C interface,
   2486           * waking only the accelerometer at fixed intervals to take a single
   2487           * measurement. The frequency of wake-ups can be configured with LP_WAKE_CTRL
   2488           * as shown below:
   2489           *
   2490           * <pre>
   2491           * LP_WAKE_CTRL | Wake-up Frequency
   2492           * -------------+------------------
   2493           * 0            | 1.25 Hz
   2494           * 1            | 2.5 Hz
   2495           * 2            | 5 Hz
   2496           * 3            | 10 Hz
   2497           * <pre>
   2498           *
   2499           * For further information regarding the MPU-60X0's power modes, please refer to
   2500           * Register 107.
   2501           *
   2502           * @return Current wake frequency
   2503           * @see MPU6050_RA_PWR_MGMT_2
   2504           */
   2505          uint8_t MPU6050::getWakeFrequency() {
   2506              I2Cdev::readBits(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_LP_WAKE_CTRL_BIT, MPU6050_PWR2_LP_WAKE_CTRL_LENGTH, buffer);
   2507              return buffer[0];
   2508          }
   2509          /** Set wake frequency in Accel-Only Low Power Mode.
   2510           * @param frequency New wake frequency
   2511           * @see MPU6050_RA_PWR_MGMT_2
   2512           */
   2513          void MPU6050::setWakeFrequency(uint8_t frequency) {
   2514              I2Cdev::writeBits(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_LP_WAKE_CTRL_BIT, MPU6050_PWR2_LP_WAKE_CTRL_LENGTH, frequency);
   2515          }
   2516          
   2517          /** Get X-axis accelerometer standby enabled status.
   2518           * If enabled, the X-axis will not gather or report data (or use power).
   2519           * @return Current X-axis standby enabled status
   2520           * @see MPU6050_RA_PWR_MGMT_2
   2521           * @see MPU6050_PWR2_STBY_XA_BIT
   2522           */
   2523          bool MPU6050::getStandbyXAccelEnabled() {
   2524              I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XA_BIT, buffer);
   2525              return buffer[0];
   2526          }
   2527          /** Set X-axis accelerometer standby enabled status.
   2528           * @param New X-axis standby enabled status
   2529           * @see getStandbyXAccelEnabled()
   2530           * @see MPU6050_RA_PWR_MGMT_2
   2531           * @see MPU6050_PWR2_STBY_XA_BIT
   2532           */
   2533          void MPU6050::setStandbyXAccelEnabled(bool enabled) {
   2534              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XA_BIT, enabled);
   2535          }
   2536          /** Get Y-axis accelerometer standby enabled status.
   2537           * If enabled, the Y-axis will not gather or report data (or use power).
   2538           * @return Current Y-axis standby enabled status
   2539           * @see MPU6050_RA_PWR_MGMT_2
   2540           * @see MPU6050_PWR2_STBY_YA_BIT
   2541           */
   2542          bool MPU6050::getStandbyYAccelEnabled() {
   2543              I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YA_BIT, buffer);
   2544              return buffer[0];
   2545          }
   2546          /** Set Y-axis accelerometer standby enabled status.
   2547           * @param New Y-axis standby enabled status
   2548           * @see getStandbyYAccelEnabled()
   2549           * @see MPU6050_RA_PWR_MGMT_2
   2550           * @see MPU6050_PWR2_STBY_YA_BIT
   2551           */
   2552          void MPU6050::setStandbyYAccelEnabled(bool enabled) {
   2553              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YA_BIT, enabled);
   2554          }
   2555          /** Get Z-axis accelerometer standby enabled status.
   2556           * If enabled, the Z-axis will not gather or report data (or use power).
   2557           * @return Current Z-axis standby enabled status
   2558           * @see MPU6050_RA_PWR_MGMT_2
   2559           * @see MPU6050_PWR2_STBY_ZA_BIT
   2560           */
   2561          bool MPU6050::getStandbyZAccelEnabled() {
   2562              I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZA_BIT, buffer);
   2563              return buffer[0];
   2564          }
   2565          /** Set Z-axis accelerometer standby enabled status.
   2566           * @param New Z-axis standby enabled status
   2567           * @see getStandbyZAccelEnabled()
   2568           * @see MPU6050_RA_PWR_MGMT_2
   2569           * @see MPU6050_PWR2_STBY_ZA_BIT
   2570           */
   2571          void MPU6050::setStandbyZAccelEnabled(bool enabled) {
   2572              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZA_BIT, enabled);
   2573          }
   2574          /** Get X-axis gyroscope standby enabled status.
   2575           * If enabled, the X-axis will not gather or report data (or use power).
   2576           * @return Current X-axis standby enabled status
   2577           * @see MPU6050_RA_PWR_MGMT_2
   2578           * @see MPU6050_PWR2_STBY_XG_BIT
   2579           */
   2580          bool MPU6050::getStandbyXGyroEnabled() {
   2581              I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XG_BIT, buffer);
   2582              return buffer[0];
   2583          }
   2584          /** Set X-axis gyroscope standby enabled status.
   2585           * @param New X-axis standby enabled status
   2586           * @see getStandbyXGyroEnabled()
   2587           * @see MPU6050_RA_PWR_MGMT_2
   2588           * @see MPU6050_PWR2_STBY_XG_BIT
   2589           */
   2590          void MPU6050::setStandbyXGyroEnabled(bool enabled) {
   2591              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XG_BIT, enabled);
   2592          }
   2593          /** Get Y-axis gyroscope standby enabled status.
   2594           * If enabled, the Y-axis will not gather or report data (or use power).
   2595           * @return Current Y-axis standby enabled status
   2596           * @see MPU6050_RA_PWR_MGMT_2
   2597           * @see MPU6050_PWR2_STBY_YG_BIT
   2598           */
   2599          bool MPU6050::getStandbyYGyroEnabled() {
   2600              I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YG_BIT, buffer);
   2601              return buffer[0];
   2602          }
   2603          /** Set Y-axis gyroscope standby enabled status.
   2604           * @param New Y-axis standby enabled status
   2605           * @see getStandbyYGyroEnabled()
   2606           * @see MPU6050_RA_PWR_MGMT_2
   2607           * @see MPU6050_PWR2_STBY_YG_BIT
   2608           */
   2609          void MPU6050::setStandbyYGyroEnabled(bool enabled) {
   2610              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YG_BIT, enabled);
   2611          }
   2612          /** Get Z-axis gyroscope standby enabled status.
   2613           * If enabled, the Z-axis will not gather or report data (or use power).
   2614           * @return Current Z-axis standby enabled status
   2615           * @see MPU6050_RA_PWR_MGMT_2
   2616           * @see MPU6050_PWR2_STBY_ZG_BIT
   2617           */
   2618          bool MPU6050::getStandbyZGyroEnabled() {
   2619              I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZG_BIT, buffer);
   2620              return buffer[0];
   2621          }
   2622          /** Set Z-axis gyroscope standby enabled status.
   2623           * @param New Z-axis standby enabled status
   2624           * @see getStandbyZGyroEnabled()
   2625           * @see MPU6050_RA_PWR_MGMT_2
   2626           * @see MPU6050_PWR2_STBY_ZG_BIT
   2627           */
   2628          void MPU6050::setStandbyZGyroEnabled(bool enabled) {
   2629              I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZG_BIT, enabled);
   2630          }
   2631          
   2632          // FIFO_COUNT* registers
   2633          
   2634          /** Get current FIFO buffer size.
   2635           * This value indicates the number of bytes stored in the FIFO buffer. This
   2636           * number is in turn the number of bytes that can be read from the FIFO buffer
   2637           * and it is directly proportional to the number of samples available given the
   2638           * set of sensor data bound to be stored in the FIFO (register 35 and 36).
   2639           * @return Current FIFO buffer size
   2640           */
   2641          uint16_t MPU6050::getFIFOCount() {
   2642              I2Cdev::readBytes(devAddr, MPU6050_RA_FIFO_COUNTH, 2, buffer);
   2643              return (((uint16_t)buffer[0]) << 8) | buffer[1];
   2644          }
   2645          
   2646          // FIFO_R_W register
   2647          
   2648          /** Get byte from FIFO buffer.
   2649           * This register is used to read and write data from the FIFO buffer. Data is
   2650           * written to the FIFO in order of register number (from lowest to highest). If
   2651           * all the FIFO enable flags (see below) are enabled and all External Sensor
   2652           * Data registers (Registers 73 to 96) are associated with a Slave device, the
   2653           * contents of registers 59 through 96 will be written in order at the Sample
   2654           * Rate.
   2655           *
   2656           * The contents of the sensor data registers (Registers 59 to 96) are written
   2657           * into the FIFO buffer when their corresponding FIFO enable flags are set to 1
   2658           * in FIFO_EN (Register 35). An additional flag for the sensor data registers
   2659           * associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).
   2660           *
   2661           * If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is
   2662           * automatically set to 1. This bit is located in INT_STATUS (Register 58).
   2663           * When the FIFO buffer has overflowed, the oldest data will be lost and new
   2664           * data will be written to the FIFO.
   2665           *
   2666           * If the FIFO buffer is empty, reading this register will return the last byte
   2667           * that was previously read from the FIFO until new data is available. The user
   2668           * should check FIFO_COUNT to ensure that the FIFO buffer is not read when
   2669           * empty.
   2670           *
   2671           * @return Byte from FIFO buffer
   2672           */
   2673          uint8_t MPU6050::getFIFOByte() {
   2674              I2Cdev::readByte(devAddr, MPU6050_RA_FIFO_R_W, buffer);
   2675              return buffer[0];
   2676          }
   2677          void MPU6050::getFIFOBytes(uint8_t *data, uint8_t length) {
   2678              I2Cdev::readBytes(devAddr, MPU6050_RA_FIFO_R_W, length, data);
   2679          }
   2680          /** Write byte to FIFO buffer.
   2681           * @see getFIFOByte()
   2682           * @see MPU6050_RA_FIFO_R_W
   2683           */
   2684          void MPU6050::setFIFOByte(uint8_t data) {
   2685              I2Cdev::writeByte(devAddr, MPU6050_RA_FIFO_R_W, data);
   2686          }
   2687          
   2688          // WHO_AM_I register
   2689          
   2690          /** Get Device ID.
   2691           * This register is used to verify the identity of the device (0b110100, 0x34).
   2692           * @return Device ID (6 bits only! should be 0x34)
   2693           * @see MPU6050_RA_WHO_AM_I
   2694           * @see MPU6050_WHO_AM_I_BIT
   2695           * @see MPU6050_WHO_AM_I_LENGTH
   2696           */
   2697          uint8_t MPU6050::getDeviceID() {
   2698              I2Cdev::readBits(devAddr, MPU6050_RA_WHO_AM_I, MPU6050_WHO_AM_I_BIT, MPU6050_WHO_AM_I_LENGTH, buffer);
   2699              return buffer[0];
   2700          }
   2701          /** Set Device ID.
   2702           * Write a new ID into the WHO_AM_I register (no idea why this should ever be
   2703           * necessary though).
   2704           * @param id New device ID to set.
   2705           * @see getDeviceID()
   2706           * @see MPU6050_RA_WHO_AM_I
   2707           * @see MPU6050_WHO_AM_I_BIT
   2708           * @see MPU6050_WHO_AM_I_LENGTH
   2709           */
   2710          void MPU6050::setDeviceID(uint8_t id) {
   2711              I2Cdev::writeBits(devAddr, MPU6050_RA_WHO_AM_I, MPU6050_WHO_AM_I_BIT, MPU6050_WHO_AM_I_LENGTH, id);
   2712          }
   2713          
   2714          // ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========
   2715          
   2716          // XG_OFFS_TC register
   2717          
   2718          uint8_t MPU6050::getOTPBankValid() {
   2719              I2Cdev::readBit(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, buffer);
   2720              return buffer[0];
   2721          }
   2722          void MPU6050::setOTPBankValid(bool enabled) {
   2723              I2Cdev::writeBit(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, enabled);
   2724          }
   2725          int8_t MPU6050::getXGyroOffset() {
   2726              I2Cdev::readBits(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, buffer);
   2727              return buffer[0];
   2728          }
   2729          void MPU6050::setXGyroOffset(int8_t offset) {
   2730              I2Cdev::writeBits(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);
   2731          }
   2732          
   2733          // YG_OFFS_TC register
   2734          
   2735          int8_t MPU6050::getYGyroOffset() {
   2736              I2Cdev::readBits(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, buffer);
   2737              return buffer[0];
   2738          }
   2739          void MPU6050::setYGyroOffset(int8_t offset) {
   2740              I2Cdev::writeBits(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);
   2741          }
   2742          
   2743          // ZG_OFFS_TC register
   2744          
   2745          int8_t MPU6050::getZGyroOffset() {
   2746              I2Cdev::readBits(devAddr, MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, buffer);
   2747              return buffer[0];
   2748          }
   2749          void MPU6050::setZGyroOffset(int8_t offset) {
   2750              I2Cdev::writeBits(devAddr, MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);
   2751          }
   2752          
   2753          // X_FINE_GAIN register
   2754          
   2755          int8_t MPU6050::getXFineGain() {
   2756              I2Cdev::readByte(devAddr, MPU6050_RA_X_FINE_GAIN, buffer);
   2757              return buffer[0];
   2758          }
   2759          void MPU6050::setXFineGain(int8_t gain) {
   2760              I2Cdev::writeByte(devAddr, MPU6050_RA_X_FINE_GAIN, gain);
   2761          }
   2762          
   2763          // Y_FINE_GAIN register
   2764          
   2765          int8_t MPU6050::getYFineGain() {
   2766              I2Cdev::readByte(devAddr, MPU6050_RA_Y_FINE_GAIN, buffer);
   2767              return buffer[0];
   2768          }
   2769          void MPU6050::setYFineGain(int8_t gain) {
   2770              I2Cdev::writeByte(devAddr, MPU6050_RA_Y_FINE_GAIN, gain);
   2771          }
   2772          
   2773          // Z_FINE_GAIN register
   2774          
   2775          int8_t MPU6050::getZFineGain() {
   2776              I2Cdev::readByte(devAddr, MPU6050_RA_Z_FINE_GAIN, buffer);
   2777              return buffer[0];
   2778          }
   2779          void MPU6050::setZFineGain(int8_t gain) {
   2780              I2Cdev::writeByte(devAddr, MPU6050_RA_Z_FINE_GAIN, gain);
   2781          }
   2782          
   2783          // XA_OFFS_* registers
   2784          
   2785          int16_t MPU6050::getXAccelOffset() {
   2786              I2Cdev::readBytes(devAddr, MPU6050_RA_XA_OFFS_H, 2, buffer);
   2787              return (((int16_t)buffer[0]) << 8) | buffer[1];
   2788          }
   2789          void MPU6050::setXAccelOffset(int16_t offset) {
   2790              I2Cdev::writeWord(devAddr, MPU6050_RA_XA_OFFS_H, offset);
   2791          }
   2792          
   2793          // YA_OFFS_* register
   2794          
   2795          int16_t MPU6050::getYAccelOffset() {
   2796              I2Cdev::readBytes(devAddr, MPU6050_RA_YA_OFFS_H, 2, buffer);
   2797              return (((int16_t)buffer[0]) << 8) | buffer[1];
   2798          }
   2799          void MPU6050::setYAccelOffset(int16_t offset) {
   2800              I2Cdev::writeWord(devAddr, MPU6050_RA_YA_OFFS_H, offset);
   2801          }
   2802          
   2803          // ZA_OFFS_* register
   2804          
   2805          int16_t MPU6050::getZAccelOffset() {
   2806              I2Cdev::readBytes(devAddr, MPU6050_RA_ZA_OFFS_H, 2, buffer);
   2807              return (((int16_t)buffer[0]) << 8) | buffer[1];
   2808          }
   2809          void MPU6050::setZAccelOffset(int16_t offset) {
   2810              I2Cdev::writeWord(devAddr, MPU6050_RA_ZA_OFFS_H, offset);
   2811          }
   2812          
   2813          // XG_OFFS_USR* registers
   2814          
   2815          int16_t MPU6050::getXGyroOffsetUser() {
   2816              I2Cdev::readBytes(devAddr, MPU6050_RA_XG_OFFS_USRH, 2, buffer);
   2817              return (((int16_t)buffer[0]) << 8) | buffer[1];
   2818          }
   2819          void MPU6050::setXGyroOffsetUser(int16_t offset) {
   2820              I2Cdev::writeWord(devAddr, MPU6050_RA_XG_OFFS_USRH, offset);
   2821          }
   2822          
   2823          // YG_OFFS_USR* register
   2824          
   2825          int16_t MPU6050::getYGyroOffsetUser() {
   2826              I2Cdev::readBytes(devAddr, MPU6050_RA_YG_OFFS_USRH, 2, buffer);
   2827              return (((int16_t)buffer[0]) << 8) | buffer[1];
   2828          }
   2829          void MPU6050::setYGyroOffsetUser(int16_t offset) {
   2830              I2Cdev::writeWord(devAddr, MPU6050_RA_YG_OFFS_USRH, offset);
   2831          }
   2832          
   2833          // ZG_OFFS_USR* register
   2834          
   2835          int16_t MPU6050::getZGyroOffsetUser() {
   2836              I2Cdev::readBytes(devAddr, MPU6050_RA_ZG_OFFS_USRH, 2, buffer);
   2837              return (((int16_t)buffer[0]) << 8) | buffer[1];
   2838          }
   2839          void MPU6050::setZGyroOffsetUser(int16_t offset) {
   2840              I2Cdev::writeWord(devAddr, MPU6050_RA_ZG_OFFS_USRH, offset);
   2841          }
   2842          
   2843          // INT_ENABLE register (DMP functions)
   2844          
   2845          bool MPU6050::getIntPLLReadyEnabled() {
   2846              I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_PLL_RDY_INT_BIT, buffer);
   2847              return buffer[0];
   2848          }
   2849          void MPU6050::setIntPLLReadyEnabled(bool enabled) {
   2850              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_PLL_RDY_INT_BIT, enabled);
   2851          }
   2852          bool MPU6050::getIntDMPEnabled() {
   2853              I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DMP_INT_BIT, buffer);
   2854              return buffer[0];
   2855          }
   2856          void MPU6050::setIntDMPEnabled(bool enabled) {
   2857              I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DMP_INT_BIT, enabled);
   2858          }
   2859          
   2860          // DMP_INT_STATUS
   2861          
   2862          bool MPU6050::getDMPInt5Status() {
   2863              I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_5_BIT, buffer);
   2864              return buffer[0];
   2865          }
   2866          bool MPU6050::getDMPInt4Status() {
   2867              I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_4_BIT, buffer);
   2868              return buffer[0];
   2869          }
   2870          bool MPU6050::getDMPInt3Status() {
   2871              I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_3_BIT, buffer);
   2872              return buffer[0];
   2873          }
   2874          bool MPU6050::getDMPInt2Status() {
   2875              I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_2_BIT, buffer);
   2876              return buffer[0];
   2877          }
   2878          bool MPU6050::getDMPInt1Status() {
   2879              I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_1_BIT, buffer);
   2880              return buffer[0];
   2881          }
   2882          bool MPU6050::getDMPInt0Status() {
   2883              I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_0_BIT, buffer);
   2884              return buffer[0];
   2885          }
   2886          
   2887          // INT_STATUS register (DMP functions)
   2888          
   2889          bool MPU6050::getIntPLLReadyStatus() {
   2890              I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_PLL_RDY_INT_BIT, buffer);
   2891              return buffer[0];
   2892          }
   2893          bool MPU6050::getIntDMPStatus() {
   2894              I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_DMP_INT_BIT, buffer);
   2895              return buffer[0];
   2896          }
   2897          
   2898          // USER_CTRL register (DMP functions)
   2899          
   2900          bool MPU6050::getDMPEnabled() {
   2901              I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, buffer);
   2902              return buffer[0];
   2903          }
   2904          void MPU6050::setDMPEnabled(bool enabled) {
   2905              I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled);
   2906          }
   2907          void MPU6050::resetDMP() {
   2908              I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, true);
   2909          }
   2910          
   2911          // BANK_SEL register
   2912          
   2913          void MPU6050::setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {
   2914              bank &= 0x1F;
   2915              if (userBank) bank |= 0x20;
   2916              if (prefetchEnabled) bank |= 0x40;
   2917              I2Cdev::writeByte(devAddr, MPU6050_RA_BANK_SEL, bank);
   2918          }
   2919          
   2920          // MEM_START_ADDR register
   2921          
   2922          void MPU6050::setMemoryStartAddress(uint8_t address) {
   2923              I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_START_ADDR, address);
   2924          }
   2925          
   2926          // MEM_R_W register
   2927          
   2928          uint8_t MPU6050::readMemoryByte() {
   2929              I2Cdev::readByte(devAddr, MPU6050_RA_MEM_R_W, buffer);
   2930              return buffer[0];
   2931          }
   2932          void MPU6050::writeMemoryByte(uint8_t data) {
   2933              I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_R_W, data);
   2934          }
   2935          void MPU6050::readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {
   2936              setMemoryBank(bank);
   2937              setMemoryStartAddress(address);
   2938              uint8_t chunkSize;
   2939              for (uint16_t i = 0; i < dataSize;) {
   2940                  // determine correct chunk size according to bank position and data size
   2941                  chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;
   2942          
   2943                  // make sure we don't go past the data size
   2944                  if (i + chunkSize > dataSize) chunkSize = dataSize - i;
   2945          
   2946                  // make sure this chunk doesn't go past the bank boundary (256 bytes)
   2947                  if (chunkSize > 256 - address) chunkSize = 256 - address;
   2948          
   2949                  // read the chunk of data as specified
   2950                  I2Cdev::readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, data + i);
   2951                  
   2952                  // increase byte index by [chunkSize]
   2953                  i += chunkSize;
   2954          
   2955                  // uint8_t automatically wraps to 0 at 256
   2956                  address += chunkSize;
   2957          
   2958                  // if we aren't done, update bank (if necessary) and address
   2959                  if (i < dataSize) {
   2960                      if (address == 0) bank++;
   2961                      setMemoryBank(bank);
   2962                      setMemoryStartAddress(address);
   2963                  }
   2964              }
   2965          }
   2966          bool MPU6050::writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {
   2967              setMemoryBank(bank);
   2968              setMemoryStartAddress(address);
   2969              uint8_t chunkSize;
   2970              uint8_t *verifyBuffer;
   2971              uint8_t *progBuffer;
   2972              uint16_t i;
   2973              uint8_t j;
   2974              if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
   2975              if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
   2976              for (i = 0; i < dataSize;) {
   2977                  // determine correct chunk size according to bank position and data size
   2978                  chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;
   2979          
   2980                  // make sure we don't go past the data size
   2981                  if (i + chunkSize > dataSize) chunkSize = dataSize - i;
   2982          
   2983                  // make sure this chunk doesn't go past the bank boundary (256 bytes)
   2984                  if (chunkSize > 256 - address) chunkSize = 256 - address;
   2985                  
   2986                  if (useProgMem) {
   2987                      // write the chunk of data as specified
   2988                      for (j = 0; j < chunkSize; j++) progBuffer[j] = data[i + j];
   2989                  } else {
   2990                      // write the chunk of data as specified
   2991                      progBuffer = (uint8_t *)data + i;
   2992                  }
   2993          
   2994                  I2Cdev::writeBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, progBuffer);
   2995          
   2996                  // verify data if needed
   2997                  if (verify && verifyBuffer) {
   2998                      setMemoryBank(bank);
   2999                      setMemoryStartAddress(address);
   3000                      I2Cdev::readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, verifyBuffer);
   3001                      if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {
   3002                          /*Serial.print("Block write verification error, bank ");
   3003                          Serial.print(bank, DEC);
   3004                          Serial.print(", address ");
   3005                          Serial.print(address, DEC);
   3006                          Serial.print("!\nExpected:");
   3007                          for (j = 0; j < chunkSize; j++) {
   3008                              Serial.print(" 0x");
   3009                              if (progBuffer[j] < 16) Serial.print("0");
   3010                              Serial.print(progBuffer[j], HEX);
   3011                          }
   3012                          Serial.print("\nReceived:");
   3013                          for (uint8_t j = 0; j < chunkSize; j++) {
   3014                              Serial.print(" 0x");
   3015                              if (verifyBuffer[i + j] < 16) Serial.print("0");
   3016                              Serial.print(verifyBuffer[i + j], HEX);
   3017                          }
   3018                          Serial.print("\n");*/
   3019                          free(verifyBuffer);
   3020                          if (useProgMem) free(progBuffer);
   3021                          return false; // uh oh.
   3022                      }
   3023                  }
   3024          
   3025                  // increase byte index by [chunkSize]
   3026                  i += chunkSize;
   3027          
   3028                  // uint8_t automatically wraps to 0 at 256
   3029                  address += chunkSize;
   3030          
   3031                  // if we aren't done, update bank (if necessary) and address
   3032                  if (i < dataSize) {
   3033                      if (address == 0) bank++;
   3034                      setMemoryBank(bank);
   3035                      setMemoryStartAddress(address);
   3036                  }
   3037              }
   3038              if (verify) free(verifyBuffer);
   3039              if (useProgMem) free(progBuffer);
   3040              return true;
   3041          }
   3042          bool MPU6050::writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify) {
   3043              return writeMemoryBlock(data, dataSize, bank, address, verify, true);
   3044          }
   3045          bool MPU6050::writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem) {
   3046              uint8_t *progBuffer, success, special;
   3047              uint16_t i, j;
   3048              if (useProgMem) {
   3049                  progBuffer = (uint8_t *)malloc(8); // assume 8-byte blocks, realloc later if necessary
   3050              }
   3051          
   3052              // config set data is a long string of blocks with the following structure:
   3053              // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
   3054              uint8_t bank, offset, length;
   3055              for (i = 0; i < dataSize;) {
   3056          #if 0 /* CRZ */
   3057                  if (useProgMem) {
   3058                      bank = pgm_read_byte(data + i++);
   3059                      offset = pgm_read_byte(data + i++);
   3060                      length = pgm_read_byte(data + i++);
   3061                  } else
   3062          #endif
   3063                  {
   3064                      bank = data[i++];
   3065                      offset = data[i++];
   3066                      length = data[i++];
   3067                  }
   3068          
   3069                  // write data or perform special action
   3070                  if (length > 0) {
   3071                      // regular block of data to write
   3072                      /*Serial.print("Writing config block to bank ");
   3073                      Serial.print(bank);
   3074                      Serial.print(", offset ");
   3075                      Serial.print(offset);
   3076                      Serial.print(", length=");
   3077                      Serial.println(length);*/
   3078                      if (useProgMem) {
   3079                          if (sizeof(progBuffer) < length) progBuffer = (uint8_t *)realloc(progBuffer, length);
   3080                          for (j = 0; j < length; j++) progBuffer[j] = data[i + j];
   3081                      } else {
   3082                          progBuffer = (uint8_t *)data + i;
   3083                      }
   3084                      success = writeMemoryBlock(progBuffer, length, bank, offset, true);
   3085                      i += length;
   3086                  } else {
   3087                      // special instruction
   3088                      // NOTE: this kind of behavior (what and when to do certain things)
   3089                      // is totally undocumented. This code is in here based on observed
   3090                      // behavior only, and exactly why (or even whether) it has to be here
   3091                      // is anybody's guess for now.
   3092          #if 0 /* CRZ */
   3093                      if (useProgMem) {
   3094                          special = pgm_read_byte(data + i++);
   3095                      } else
   3096          #endif
   3097                      {
   3098                          special = data[i++];
   3099                      }
   3100                      /*Serial.print("Special command code ");
   3101                      Serial.print(special, HEX);
   3102                      Serial.println(" found...");*/
   3103                      if (special == 0x01) {
   3104                          // enable DMP-related interrupts
   3105                          
   3106                          //setIntZeroMotionEnabled(true);
   3107                          //setIntFIFOBufferOverflowEnabled(true);
   3108                          //setIntDMPEnabled(true);
   3109                          I2Cdev::writeByte(devAddr, MPU6050_RA_INT_ENABLE, 0x32);  // single operation
   3110          
   3111                          success = true;
   3112                      } else {
   3113                          // unknown special command
   3114                          success = false;
   3115                      }
   3116                  }
   3117                  
   3118                  if (!success) {
   3119                      if (useProgMem) free(progBuffer);
   3120                      return false; // uh oh
   3121                  }
   3122              }
   3123              if (useProgMem) free(progBuffer);
   3124              return true;
   3125          }
   3126          bool MPU6050::writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {
   3127              return writeDMPConfigurationSet(data, dataSize, true);
   3128          }
   3129          
   3130          // DMP_CFG_1 register
   3131          
   3132          uint8_t MPU6050::getDMPConfig1() {
   3133              I2Cdev::readByte(devAddr, MPU6050_RA_DMP_CFG_1, buffer);
   3134              return buffer[0];
   3135          }
   3136          void MPU6050::setDMPConfig1(uint8_t config) {
   3137              I2Cdev::writeByte(devAddr, MPU6050_RA_DMP_CFG_1, config);
   3138          }
   3139          
   3140          // DMP_CFG_2 register
   3141          
   3142          uint8_t MPU6050::getDMPConfig2() {
   3143              I2Cdev::readByte(devAddr, MPU6050_RA_DMP_CFG_2, buffer);
   3144              return buffer[0];
   3145          }
   3146          void MPU6050::setDMPConfig2(uint8_t config) {
   3147              I2Cdev::writeByte(devAddr, MPU6050_RA_DMP_CFG_2, config);
   3148          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  MPU6050::MPU6050()
        0  MPU6050::MPU6050(uint8_t)
       16  MPU6050::getAccelFIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getAccelXSelfTest()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getAccelYSelfTest()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getAccelZSelfTest()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       24  MPU6050::getAcceleration(int16_t *, int16_t *, int16_t *)
             24 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getAccelerationX()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getAccelerationY()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getAccelerationZ()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getAccelerometerPowerOnDelay()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getAuxVDDIOLevel()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getClockOutputEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getClockSource()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDHPFMode()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDLPFMode()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getDMPConfig1()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getDMPConfig2()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDMPEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDMPInt0Status()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDMPInt1Status()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDMPInt2Status()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDMPInt3Status()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDMPInt4Status()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDMPInt5Status()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getDeviceID()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getExternalFrameSync()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getExternalSensorByte(int)
             16 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getExternalSensorDWord(int)
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getExternalSensorWord(int)
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getExternalShadowDelayEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getFIFOByte()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       24  MPU6050::getFIFOBytes(uint8_t *, uint8_t)
             24 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getFIFOCount()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getFIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getFSyncInterruptEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getFSyncInterruptLevel()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getFreefallDetectionCounterDecrement()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getFreefallDetectionDuration()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getFreefallDetectionThreshold()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getFullScaleAccelRange()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getFullScaleGyroRange()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getI2CBypassEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getI2CMasterModeEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntDMPEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntDMPStatus()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntDataReadyEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntDataReadyStatus()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getIntEnabled()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntFIFOBufferOverflowEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntFIFOBufferOverflowStatus()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntFreefallEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntFreefallStatus()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntI2CMasterEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntI2CMasterStatus()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntMotionEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntMotionStatus()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntPLLReadyEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntPLLReadyStatus()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getIntStatus()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntZeroMotionEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getIntZeroMotionStatus()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getInterruptDrive()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getInterruptLatch()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getInterruptLatchClear()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getInterruptMode()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getLostArbitration()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getMasterClockSpeed()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       40  MPU6050::getMotion6(int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *)
             40 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       56  MPU6050::getMotion9(int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *)
             56 -> Delay
             56 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
             56 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
             56 -> MPU6050::getMotion6(int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *)
       16  MPU6050::getMotionDetectionCounterDecrement()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getMotionDetectionDuration()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getMotionDetectionThreshold()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getMultiMasterEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getOTPBankValid()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getPassthroughStatus()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getRate()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       24  MPU6050::getRotation(int16_t *, int16_t *, int16_t *)
             24 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getRotationX()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getRotationY()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getRotationZ()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getSlate4InputByte()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave0FIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave0Nack()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave1FIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave1Nack()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave2FIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave2Nack()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave3FIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave3Nack()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getSlave4Address()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave4Enabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave4InterruptEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave4IsDone()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave4MasterDelay()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave4Nack()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getSlave4Register()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlave4WriteMode()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlaveAddress(uint8_t)
             16 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       24  MPU6050::getSlaveDataLength(uint8_t)
             24 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlaveDelayEnabled(uint8_t)
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlaveEnabled(uint8_t)
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlaveReadWriteTransitionEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlaveRegister(uint8_t)
             16 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlaveWordByteSwap(uint8_t)
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlaveWordGroupOffset(uint8_t)
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSlaveWriteMode(uint8_t)
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getSleepEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getStandbyXAccelEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getStandbyXGyroEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getStandbyYAccelEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getStandbyYGyroEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getStandbyZAccelEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getStandbyZGyroEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getTempFIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getTempSensorEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getTemperature()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getWaitForExternalSensorEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getWakeCycleEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getWakeFrequency()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getXAccelOffset()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getXFineGain()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getXGyroFIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getXGyroOffset()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getXGyroOffsetUser()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getXNegMotionDetected()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getXPosMotionDetected()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getYAccelOffset()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getYFineGain()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getYGyroFIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getYGyroOffset()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getYGyroOffsetUser()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getYNegMotionDetected()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getYPosMotionDetected()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getZAccelOffset()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getZFineGain()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getZGyroFIFOEnabled()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getZGyroOffset()
             16 -> I2Cdev::readBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getZGyroOffsetUser()
             16 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getZNegMotionDetected()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getZPosMotionDetected()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
       16  MPU6050::getZeroMotionDetected()
             16 -> I2Cdev::readBit(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getZeroMotionDetectionDuration()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::getZeroMotionDetectionThreshold()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::initialize()
              8 -> MPU6050::setClockSource(uint8_t)
              8 -> MPU6050::setFullScaleAccelRange(uint8_t)
              8 -> MPU6050::setFullScaleGyroRange(uint8_t)
              8 -> MPU6050::setSleepEnabled(bool)
       40  MPU6050::readMemoryBlock(uint8_t *, uint16_t, uint8_t, uint8_t)
             40 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
             40 -> MPU6050::setMemoryBank(uint8_t, bool, bool)
             40 -> MPU6050::setMemoryStartAddress(uint8_t)
        8  MPU6050::readMemoryByte()
              8 -> I2Cdev::readByte(uint8_t, uint8_t, uint8_t *, uint16_t)
        8  MPU6050::reset()
              8 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
        8  MPU6050::resetAccelerometerPath()
              8 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
        8  MPU6050::resetDMP()
              8 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
        8  MPU6050::resetFIFO()
              8 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
        8  MPU6050::resetGyroscopePath()
              8 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
        8  MPU6050::resetI2CMaster()
              8 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
        8  MPU6050::resetSensors()
              8 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
        8  MPU6050::resetTemperaturePath()
              8 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setAccelFIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setAccelXSelfTest(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setAccelYSelfTest(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setAccelZSelfTest(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setAccelerometerPowerOnDelay(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setAuxVDDIOLevel(uint8_t)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setClockOutputEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setClockSource(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setDHPFMode(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setDLPFMode(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setDMPConfig1(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setDMPConfig2(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setDMPEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setDeviceID(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setExternalFrameSync(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setExternalShadowDelayEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setFIFOByte(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setFIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setFSyncInterruptEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setFSyncInterruptLevel(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setFreefallDetectionCounterDecrement(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setFreefallDetectionDuration(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setFreefallDetectionThreshold(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setFullScaleAccelRange(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setFullScaleGyroRange(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setI2CBypassEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setI2CMasterModeEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setIntDMPEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setIntDataReadyEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setIntEnabled(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setIntFIFOBufferOverflowEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setIntFreefallEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setIntI2CMasterEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setIntMotionEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setIntPLLReadyEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setIntZeroMotionEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setInterruptDrive(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setInterruptLatch(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setInterruptLatchClear(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setInterruptMode(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setMasterClockSpeed(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       24  MPU6050::setMemoryBank(uint8_t, bool, bool)
             24 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setMemoryStartAddress(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setMotionDetectionCounterDecrement(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setMotionDetectionDuration(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setMotionDetectionThreshold(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setMultiMasterEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setOTPBankValid(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setRate(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave0FIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave1FIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave2FIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave3FIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave4Address(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave4Enabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave4InterruptEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave4MasterDelay(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave4OutputByte(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave4Register(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlave4WriteMode(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlaveAddress(uint8_t, uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       24  MPU6050::setSlaveDataLength(uint8_t, uint8_t)
             24 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlaveDelayEnabled(uint8_t, bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlaveEnabled(uint8_t, bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlaveOutputByte(uint8_t, uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlaveReadWriteTransitionEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlaveRegister(uint8_t, uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlaveWordByteSwap(uint8_t, bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlaveWordGroupOffset(uint8_t, bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSlaveWriteMode(uint8_t, bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setSleepEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setStandbyXAccelEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setStandbyXGyroEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setStandbyYAccelEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setStandbyYGyroEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setStandbyZAccelEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setStandbyZGyroEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setTempFIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setTempSensorEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setWaitForExternalSensorEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setWakeCycleEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setWakeFrequency(uint8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setXAccelOffset(int16_t)
             16 -> I2Cdev::writeWord(uint8_t, uint8_t, uint16_t)
       16  MPU6050::setXFineGain(int8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setXGyroFIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setXGyroOffset(int8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setXGyroOffsetUser(int16_t)
             16 -> I2Cdev::writeWord(uint8_t, uint8_t, uint16_t)
       16  MPU6050::setYAccelOffset(int16_t)
             16 -> I2Cdev::writeWord(uint8_t, uint8_t, uint16_t)
       16  MPU6050::setYFineGain(int8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setYGyroFIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setYGyroOffset(int8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setYGyroOffsetUser(int16_t)
             16 -> I2Cdev::writeWord(uint8_t, uint8_t, uint16_t)
       16  MPU6050::setZAccelOffset(int16_t)
             16 -> I2Cdev::writeWord(uint8_t, uint8_t, uint16_t)
       16  MPU6050::setZFineGain(int8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setZGyroFIFOEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setZGyroOffset(int8_t)
             16 -> I2Cdev::writeBits(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
       16  MPU6050::setZGyroOffsetUser(int16_t)
             16 -> I2Cdev::writeWord(uint8_t, uint8_t, uint16_t)
       16  MPU6050::setZeroMotionDetectionDuration(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::setZeroMotionDetectionThreshold(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
        8  MPU6050::subobject MPU6050()
              8 -> MPU6050::MPU6050()
        8  MPU6050::subobject MPU6050(uint8_t)
              8 -> MPU6050::MPU6050(uint8_t)
       16  MPU6050::switchSPIEnabled(bool)
             16 -> I2Cdev::writeBit(uint8_t, uint8_t, uint8_t, uint8_t)
        8  MPU6050::testConnection()
              8 -> MPU6050::getDeviceID()
       64  MPU6050::writeDMPConfigurationSet(uint8_t const *, uint16_t, bool)
             64 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
             64 -> MPU6050::writeMemoryBlock(uint8_t const *, uint16_t, uint8_t, uint8_t, bool, bool)
             64 -> free
             64 -> malloc
             64 -> realloc
       48  MPU6050::writeMemoryBlock(uint8_t const *, uint16_t, uint8_t, uint8_t, bool, bool)
             48 -> I2Cdev::readBytes(uint8_t, uint8_t, uint8_t, uint8_t *, uint16_t)
             48 -> I2Cdev::writeBytes(uint8_t, uint8_t, uint8_t, uint8_t *)
             48 -> MPU6050::setMemoryBank(uint8_t, bool, bool)
             48 -> MPU6050::setMemoryStartAddress(uint8_t)
             48 -> free
             48 -> malloc
             48 -> memcmp
       16  MPU6050::writeMemoryByte(uint8_t)
             16 -> I2Cdev::writeByte(uint8_t, uint8_t, uint8_t)
       16  MPU6050::writeProgDMPConfigurationSet(uint8_t const *, uint16_t)
             16 -> MPU6050::writeDMPConfigurationSet(uint8_t const *, uint16_t, bool)
       40  MPU6050::writeProgMemoryBlock(uint8_t const *, uint16_t, uint8_t, uint8_t, bool)
             40 -> MPU6050::writeMemoryBlock(uint8_t const *, uint16_t, uint8_t, uint8_t, bool, bool)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       6  MPU6050::MPU6050()
       4  MPU6050::MPU6050(uint8_t)
      40  MPU6050::getAccelFIFOEnabled()
      40  MPU6050::getAccelXSelfTest()
      40  MPU6050::getAccelYSelfTest()
      40  MPU6050::getAccelZSelfTest()
      60  MPU6050::getAcceleration(int16_t *, int16_t *, int16_t *)
      36  MPU6050::getAccelerationX()
      36  MPU6050::getAccelerationY()
      36  MPU6050::getAccelerationZ()
      30  MPU6050::getAccelerometerPowerOnDelay()
      28  MPU6050::getAuxVDDIOLevel()
      40  MPU6050::getClockOutputEnabled()
      30  MPU6050::getClockSource()
      30  MPU6050::getDHPFMode()
      30  MPU6050::getDLPFMode()
      22  MPU6050::getDMPConfig1()
      22  MPU6050::getDMPConfig2()
      40  MPU6050::getDMPEnabled()
      40  MPU6050::getDMPInt0Status()
      40  MPU6050::getDMPInt1Status()
      40  MPU6050::getDMPInt2Status()
      40  MPU6050::getDMPInt3Status()
      40  MPU6050::getDMPInt4Status()
      40  MPU6050::getDMPInt5Status()
      30  MPU6050::getDeviceID()
      30  MPU6050::getExternalFrameSync()
      28  MPU6050::getExternalSensorByte(int)
      50  MPU6050::getExternalSensorDWord(int)
      40  MPU6050::getExternalSensorWord(int)
      40  MPU6050::getExternalShadowDelayEnabled()
      22  MPU6050::getFIFOByte()
      32  MPU6050::getFIFOBytes(uint8_t *, uint8_t)
      36  MPU6050::getFIFOCount()
      40  MPU6050::getFIFOEnabled()
      40  MPU6050::getFSyncInterruptEnabled()
      40  MPU6050::getFSyncInterruptLevel()
      30  MPU6050::getFreefallDetectionCounterDecrement()
      22  MPU6050::getFreefallDetectionDuration()
      22  MPU6050::getFreefallDetectionThreshold()
      30  MPU6050::getFullScaleAccelRange()
      30  MPU6050::getFullScaleGyroRange()
      40  MPU6050::getI2CBypassEnabled()
      40  MPU6050::getI2CMasterModeEnabled()
      40  MPU6050::getIntDMPEnabled()
      40  MPU6050::getIntDMPStatus()
      40  MPU6050::getIntDataReadyEnabled()
      40  MPU6050::getIntDataReadyStatus()
      22  MPU6050::getIntEnabled()
      40  MPU6050::getIntFIFOBufferOverflowEnabled()
      40  MPU6050::getIntFIFOBufferOverflowStatus()
      40  MPU6050::getIntFreefallEnabled()
      40  MPU6050::getIntFreefallStatus()
      40  MPU6050::getIntI2CMasterEnabled()
      40  MPU6050::getIntI2CMasterStatus()
      40  MPU6050::getIntMotionEnabled()
      40  MPU6050::getIntMotionStatus()
      40  MPU6050::getIntPLLReadyEnabled()
      40  MPU6050::getIntPLLReadyStatus()
      22  MPU6050::getIntStatus()
      40  MPU6050::getIntZeroMotionEnabled()
      40  MPU6050::getIntZeroMotionStatus()
      40  MPU6050::getInterruptDrive()
      40  MPU6050::getInterruptLatch()
      40  MPU6050::getInterruptLatchClear()
      40  MPU6050::getInterruptMode()
      40  MPU6050::getLostArbitration()
      30  MPU6050::getMasterClockSpeed()
     114  MPU6050::getMotion6(int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *)
     142  MPU6050::getMotion9(int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *, int16_t *)
      30  MPU6050::getMotionDetectionCounterDecrement()
      22  MPU6050::getMotionDetectionDuration()
      22  MPU6050::getMotionDetectionThreshold()
      40  MPU6050::getMultiMasterEnabled()
      28  MPU6050::getOTPBankValid()
      40  MPU6050::getPassthroughStatus()
      22  MPU6050::getRate()
      60  MPU6050::getRotation(int16_t *, int16_t *, int16_t *)
      36  MPU6050::getRotationX()
      36  MPU6050::getRotationY()
      36  MPU6050::getRotationZ()
      22  MPU6050::getSlate4InputByte()
      40  MPU6050::getSlave0FIFOEnabled()
      40  MPU6050::getSlave0Nack()
      40  MPU6050::getSlave1FIFOEnabled()
      40  MPU6050::getSlave1Nack()
      40  MPU6050::getSlave2FIFOEnabled()
      40  MPU6050::getSlave2Nack()
      40  MPU6050::getSlave3FIFOEnabled()
      40  MPU6050::getSlave3Nack()
      22  MPU6050::getSlave4Address()
      40  MPU6050::getSlave4Enabled()
      40  MPU6050::getSlave4InterruptEnabled()
      40  MPU6050::getSlave4IsDone()
      30  MPU6050::getSlave4MasterDelay()
      40  MPU6050::getSlave4Nack()
      22  MPU6050::getSlave4Register()
      40  MPU6050::getSlave4WriteMode()
      46  MPU6050::getSlaveAddress(uint8_t)
      56  MPU6050::getSlaveDataLength(uint8_t)
      52  MPU6050::getSlaveDelayEnabled(uint8_t)
      62  MPU6050::getSlaveEnabled(uint8_t)
      40  MPU6050::getSlaveReadWriteTransitionEnabled()
      46  MPU6050::getSlaveRegister(uint8_t)
      62  MPU6050::getSlaveWordByteSwap(uint8_t)
      62  MPU6050::getSlaveWordGroupOffset(uint8_t)
      62  MPU6050::getSlaveWriteMode(uint8_t)
      40  MPU6050::getSleepEnabled()
      40  MPU6050::getStandbyXAccelEnabled()
      40  MPU6050::getStandbyXGyroEnabled()
      40  MPU6050::getStandbyYAccelEnabled()
      40  MPU6050::getStandbyYGyroEnabled()
      40  MPU6050::getStandbyZAccelEnabled()
      40  MPU6050::getStandbyZGyroEnabled()
      40  MPU6050::getTempFIFOEnabled()
      40  MPU6050::getTempSensorEnabled()
      36  MPU6050::getTemperature()
      40  MPU6050::getWaitForExternalSensorEnabled()
      40  MPU6050::getWakeCycleEnabled()
      30  MPU6050::getWakeFrequency()
      36  MPU6050::getXAccelOffset()
      26  MPU6050::getXFineGain()
      40  MPU6050::getXGyroFIFOEnabled()
      34  MPU6050::getXGyroOffset()
      36  MPU6050::getXGyroOffsetUser()
      40  MPU6050::getXNegMotionDetected()
      40  MPU6050::getXPosMotionDetected()
      36  MPU6050::getYAccelOffset()
      26  MPU6050::getYFineGain()
      40  MPU6050::getYGyroFIFOEnabled()
      34  MPU6050::getYGyroOffset()
      36  MPU6050::getYGyroOffsetUser()
      40  MPU6050::getYNegMotionDetected()
      40  MPU6050::getYPosMotionDetected()
      36  MPU6050::getZAccelOffset()
      26  MPU6050::getZFineGain()
      40  MPU6050::getZGyroFIFOEnabled()
      34  MPU6050::getZGyroOffset()
      36  MPU6050::getZGyroOffsetUser()
      40  MPU6050::getZNegMotionDetected()
      40  MPU6050::getZPosMotionDetected()
      40  MPU6050::getZeroMotionDetected()
      22  MPU6050::getZeroMotionDetectionDuration()
      22  MPU6050::getZeroMotionDetectionThreshold()
      38  MPU6050::initialize()
     188  MPU6050::readMemoryBlock(uint8_t *, uint16_t, uint8_t, uint8_t)
      22  MPU6050::readMemoryByte()
      18  MPU6050::reset()
      18  MPU6050::resetAccelerometerPath()
      18  MPU6050::resetDMP()
      18  MPU6050::resetFIFO()
      18  MPU6050::resetGyroscopePath()
      18  MPU6050::resetI2CMaster()
      18  MPU6050::resetSensors()
      18  MPU6050::resetTemperaturePath()
      22  MPU6050::setAccelFIFOEnabled(bool)
      22  MPU6050::setAccelXSelfTest(bool)
      22  MPU6050::setAccelYSelfTest(bool)
      22  MPU6050::setAccelZSelfTest(bool)
      24  MPU6050::setAccelerometerPowerOnDelay(uint8_t)
      22  MPU6050::setAuxVDDIOLevel(uint8_t)
      22  MPU6050::setClockOutputEnabled(bool)
      24  MPU6050::setClockSource(uint8_t)
      24  MPU6050::setDHPFMode(uint8_t)
      24  MPU6050::setDLPFMode(uint8_t)
      20  MPU6050::setDMPConfig1(uint8_t)
      20  MPU6050::setDMPConfig2(uint8_t)
      22  MPU6050::setDMPEnabled(bool)
      24  MPU6050::setDeviceID(uint8_t)
      24  MPU6050::setExternalFrameSync(uint8_t)
      22  MPU6050::setExternalShadowDelayEnabled(bool)
      20  MPU6050::setFIFOByte(uint8_t)
      22  MPU6050::setFIFOEnabled(bool)
      22  MPU6050::setFSyncInterruptEnabled(bool)
      22  MPU6050::setFSyncInterruptLevel(bool)
      24  MPU6050::setFreefallDetectionCounterDecrement(uint8_t)
      20  MPU6050::setFreefallDetectionDuration(uint8_t)
      20  MPU6050::setFreefallDetectionThreshold(uint8_t)
      24  MPU6050::setFullScaleAccelRange(uint8_t)
      24  MPU6050::setFullScaleGyroRange(uint8_t)
      22  MPU6050::setI2CBypassEnabled(bool)
      22  MPU6050::setI2CMasterModeEnabled(bool)
      22  MPU6050::setIntDMPEnabled(bool)
      22  MPU6050::setIntDataReadyEnabled(bool)
      20  MPU6050::setIntEnabled(uint8_t)
      22  MPU6050::setIntFIFOBufferOverflowEnabled(bool)
      22  MPU6050::setIntFreefallEnabled(bool)
      22  MPU6050::setIntI2CMasterEnabled(bool)
      22  MPU6050::setIntMotionEnabled(bool)
      22  MPU6050::setIntPLLReadyEnabled(bool)
      22  MPU6050::setIntZeroMotionEnabled(bool)
      22  MPU6050::setInterruptDrive(bool)
      22  MPU6050::setInterruptLatch(bool)
      22  MPU6050::setInterruptLatchClear(bool)
      22  MPU6050::setInterruptMode(bool)
      24  MPU6050::setMasterClockSpeed(uint8_t)
      48  MPU6050::setMemoryBank(uint8_t, bool, bool)
      20  MPU6050::setMemoryStartAddress(uint8_t)
      24  MPU6050::setMotionDetectionCounterDecrement(uint8_t)
      20  MPU6050::setMotionDetectionDuration(uint8_t)
      20  MPU6050::setMotionDetectionThreshold(uint8_t)
      22  MPU6050::setMultiMasterEnabled(bool)
      22  MPU6050::setOTPBankValid(bool)
      20  MPU6050::setRate(uint8_t)
      22  MPU6050::setSlave0FIFOEnabled(bool)
      22  MPU6050::setSlave1FIFOEnabled(bool)
      22  MPU6050::setSlave2FIFOEnabled(bool)
      22  MPU6050::setSlave3FIFOEnabled(bool)
      20  MPU6050::setSlave4Address(uint8_t)
      22  MPU6050::setSlave4Enabled(bool)
      22  MPU6050::setSlave4InterruptEnabled(bool)
      24  MPU6050::setSlave4MasterDelay(uint8_t)
      20  MPU6050::setSlave4OutputByte(uint8_t)
      20  MPU6050::setSlave4Register(uint8_t)
      22  MPU6050::setSlave4WriteMode(bool)
      40  MPU6050::setSlaveAddress(uint8_t, uint8_t)
      46  MPU6050::setSlaveDataLength(uint8_t, uint8_t)
      26  MPU6050::setSlaveDelayEnabled(uint8_t, bool)
      42  MPU6050::setSlaveEnabled(uint8_t, bool)
      32  MPU6050::setSlaveOutputByte(uint8_t, uint8_t)
      22  MPU6050::setSlaveReadWriteTransitionEnabled(bool)
      40  MPU6050::setSlaveRegister(uint8_t, uint8_t)
      42  MPU6050::setSlaveWordByteSwap(uint8_t, bool)
      42  MPU6050::setSlaveWordGroupOffset(uint8_t, bool)
      42  MPU6050::setSlaveWriteMode(uint8_t, bool)
      22  MPU6050::setSleepEnabled(bool)
      22  MPU6050::setStandbyXAccelEnabled(bool)
      22  MPU6050::setStandbyXGyroEnabled(bool)
      22  MPU6050::setStandbyYAccelEnabled(bool)
      22  MPU6050::setStandbyYGyroEnabled(bool)
      22  MPU6050::setStandbyZAccelEnabled(bool)
      22  MPU6050::setStandbyZGyroEnabled(bool)
      22  MPU6050::setTempFIFOEnabled(bool)
      24  MPU6050::setTempSensorEnabled(bool)
      22  MPU6050::setWaitForExternalSensorEnabled(bool)
      22  MPU6050::setWakeCycleEnabled(bool)
      24  MPU6050::setWakeFrequency(uint8_t)
      20  MPU6050::setXAccelOffset(int16_t)
      20  MPU6050::setXFineGain(int8_t)
      22  MPU6050::setXGyroFIFOEnabled(bool)
      24  MPU6050::setXGyroOffset(int8_t)
      20  MPU6050::setXGyroOffsetUser(int16_t)
      20  MPU6050::setYAccelOffset(int16_t)
      20  MPU6050::setYFineGain(int8_t)
      22  MPU6050::setYGyroFIFOEnabled(bool)
      24  MPU6050::setYGyroOffset(int8_t)
      20  MPU6050::setYGyroOffsetUser(int16_t)
      20  MPU6050::setZAccelOffset(int16_t)
      20  MPU6050::setZFineGain(int8_t)
      22  MPU6050::setZGyroFIFOEnabled(bool)
      24  MPU6050::setZGyroOffset(int8_t)
      20  MPU6050::setZGyroOffsetUser(int16_t)
      20  MPU6050::setZeroMotionDetectionDuration(uint8_t)
      20  MPU6050::setZeroMotionDetectionThreshold(uint8_t)
      12  MPU6050::subobject MPU6050()
      14  MPU6050::subobject MPU6050(uint8_t)
      22  MPU6050::switchSPIEnabled(bool)
      24  MPU6050::testConnection()
     320  MPU6050::writeDMPConfigurationSet(uint8_t const *, uint16_t, bool)
     406  MPU6050::writeMemoryBlock(uint8_t const *, uint16_t, uint8_t, uint8_t, bool, bool)
      20  MPU6050::writeMemoryByte(uint8_t)
      24  MPU6050::writeProgDMPConfigurationSet(uint8_t const *, uint16_t)
      48  MPU6050::writeProgMemoryBlock(uint8_t const *, uint16_t, uint8_t, uint8_t, bool)

 
 9 110 bytes in section .text
 
 9 110 bytes of CODE memory

Errors: none
Warnings: none
